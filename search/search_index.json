{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#python-ember-mug","title":"Python Ember Mug","text":"<p>Python Library for interacting with Ember Mugs, Cups, and Travel Mugs via Bluetooth</p> <ul> <li>\ud83d\udcd8 Documentation</li> <li>\ud83d\udcbb GitHub</li> <li>\ud83d\udc0d PyPI</li> </ul>"},{"location":"#summary","title":"Summary","text":"<p>This is an unofficial library to attempt to interact with Ember Mugs via Bluetooth. This was created for use with my Home Assistant integration, but could be useful separately and has a simple CLI interface too.</p> <p>All known Ember Mugs, Cups, Tumblers and Travel Mugs have been tested and seem to work well. If I missed one, or you have new feature ideas or issues, please create an issue, if it isn't already there, and we'll figure it out.</p> Device Tested Mug \u2713 Mug 2 \u2713 Cup \u2713 Tumbler \u2713 Travel Mug \u2713 Travel Mug 2 \u2713"},{"location":"#features","title":"Features","text":"<ul> <li>Finding devices</li> <li>Connecting to devices</li> <li>Reading/Writing most values</li> <li>Poll for changes</li> </ul> <p>Attributes by device:</p> Attribute Mug Cup Tumbler Travel Mug Description Name R/W N/A N/A R Name to give device LED Colour R/W R/W R/W N/A Colour of front LED Current Temperature R R R R Current temperature of the liquid in the mug Target Temperature R/W R/W R/W R/W Desired temperature for the liquid Temperature Unit R/W R/W R/W R/W Internal temperature unit for the app (C/F) Liquid Level R R R R Approximate level of the liquid in the device Volume level N/A N/A N/A R/W Volume of the button press beep Battery Percent R R R R Current battery level On Charger R R R R Device is on it's charger <p>Note Writing may only work if the devices has been set up in the app previously</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#python","title":"Python","text":"<pre><code>from ember_mug.scanner import find_device, discover_devices\nfrom ember_mug.utils import get_model_info_from_advertiser_data\nfrom ember_mug.mug import EmberMug\n\n# if first time with mug in pairing\ndevices = await discover_devices()\n\n# after paired you can simply use\ndevice, advertisement = await find_device()\nmodel_info = get_model_info_from_advertiser_data(advertisement)\nmug = EmberMug(device, model_info)\nawait mug.update_all()\nprint(mug.data.formatted)\nawait mug.disconnect()\n\n# You can also use connection as a context manager\n# if you want to ensure connection before starting and cleanup on exit\nasync with mug.connection():\n    print('Connected.\\nFetching Info')\n    await mug.update_all()\n    print(mug.data.formatted)\n</code></pre>"},{"location":"#cli-mode","title":"CLI Mode","text":"<p>It can also be run via command line either directly with <code>ember-mug --help</code> or as a module with <code>python -m ember_mug --help</code> There are four options with different subsections. You can see them by specifying them before help. eg <code>ember-mug poll --help</code></p> <pre><code>ember-mug discover  # Finds the mug in pairing mode for the first time\nember-mug poll  # fetches info and keeps listening for notifications\nember-mug get name target-temp  # Prints name and target temp of mug\nember-mug set --name \"My mug\" --target-temp 56.8  # Sets the name and target temp to specified values\n</code></pre> <p>Basic options:</p> Command Use <code>discover</code> Find/List all detected unpaired devices in pairing mode <code>find</code> Find one already paired devices <code>info</code> Connect to one device and print its current state <code>poll</code> Connect to one device and print its current state and keep watching for changes <code>get</code> Get the value(s) of one or more attribute(s) by name <code>set</code> Set one or more values on the device <p>Example:</p> ember-mug pollFound device: C9:0F:59:D6:33:F9: Ember Ceramic MugConnecting...Connected.Fetching InfoDevice Data+--------------+----------------------+| Device Name  | Jesse's Mug          |+--------------+----------------------+| Meta         | None                 |+--------------+----------------------+| Battery      | 64.0%                ||              | not on charging base |+--------------+----------------------+| Firmware     | None                 |+--------------+----------------------+| LED Colour   | #ff0fbb              |+--------------+----------------------+| Liquid State | Empty                |+--------------+----------------------+| Liquid Level | 0.00%                |+--------------+----------------------+| Current Temp | 24.50\u00b0C              |+--------------+----------------------+| Target Temp  | 55.00\u00b0C              |+--------------+----------------------+| Use Metric   | True                 |+--------------+----------------------+Watching for changesCurrent Temp changed from \"24.50\u00b0C\" to \"25.50\u00b0\"Battery changed from \"64.0%, on charging base\" to \"65.5%, on charging base\""},{"location":"#caveats","title":"Caveats","text":"<ul> <li>Since this api is not public, a lot of guesswork and reverse engineering is involved, so it's not perfect.</li> <li>If the device has not been set up in the app since it was reset, writing is not allowed. I don't know what they set in the app, but it changes something, and it doesn't work without it.</li> <li>Once that device has been set up in the app, you should ideally forget the device or at least turn off bluetooth whilst using it here, or you will probably get disconnected often</li> <li>I haven't figured out some attributes like udsk, dsk, location and timezone, but they are not very useful anyway.</li> </ul>"},{"location":"#troubleshooting","title":"Troubleshooting","text":""},{"location":"#systematic-timeouts-or-le-connection-abort-by-local","title":"Systematic timeouts or <code>le-connection-abort-by-local</code>","text":"<p>If your mug gets stuck in a state where it refuses to connect, you get constant reconnects, timeouts, and/or <code>le-connection-abort-by-local</code> messages in the debug logs, you may need to remove your mug via <code>bluetoothctl remove my-mac-address</code> and factory reset your device. It should reconnect correctly afterward. You may also need to re-add it to the app in order to make it writable again as well.</p>"},{"location":"#operation-failed-with-att-error-0x0e-or-another-connection-error","title":"'Operation failed with ATT error: 0x0e' or another connection error","text":"<p>This seems to be caused by the bluetooth adaptor being in some sort of passive mode. I have not yet figured out how to wake it programmatically so sadly, you need to manually open <code>bluetoothctl</code> to do so. Please ensure the device is in pairing mode (ie the light is flashing blue or says \"PAIR\") and run the <code>bluetoothctl</code> command. You don't need to type anything. run it and wait until the mug connects.</p>"},{"location":"#development","title":"Development","text":"<p>Install: - hatch - pre-commit</p> <pre><code>pip install hatch\n# Use CLI interface\nhatch run ember-mug --help\n# Run Tests\nhatch run test:cov\n# View docs\nhatch docs:serve\n# Lint code\npre-commit run --all-files\n</code></pre>"},{"location":"#credits","title":"Credits","text":"<p>This package was created with Cookiecutter and the waynerv/cookiecutter-pypackage project template.</p>"},{"location":"#notice-of-non-affiliation-and-disclaimer","title":"Notice of Non-Affiliation and Disclaimer","text":"<p>This project is not affiliated, associated, authorized, endorsed by, or in any way officially connected with Ember.</p> <p>The name Ember as well as related names, marks, emblems and images are registered trademarks of their respective owners.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":""},{"location":"changelog/#120---2025-08-29","title":"[1.2.0] - 2025-08-29","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Remove <code>service_uuids</code> filtering for <code>find_mug</code> method</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Removed tests folder from packaging</li> </ul>"},{"location":"changelog/#111---2025-03-25","title":"[1.1.1] - 2025-03-25","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Change -51 to represent 14oz Ember Mug 2 (by @Flight-Lab)</li> </ul>"},{"location":"changelog/#110---2024-11-02","title":"[1.1.0] - 2024-11-02","text":""},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Rename <code>find_mug</code> and <code>discover_mugs</code> to <code>find_device</code> and <code>discover_devices</code> respectively</li> <li>Improved documentation</li> <li>Bumped Bleak to 0.22.2</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Dropped support for Python 3.10</li> </ul>"},{"location":"changelog/#101---2024-06-15","title":"[1.0.1] - 2024-06-15","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>discover method - <code>discovered_devices_and_advertisement_data</code> is a dict and not a list (#62)</li> </ul>"},{"location":"changelog/#100---2024-02-25","title":"[1.0.0] - 2024-02-25","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Log statistics when debug is selected</li> <li>Min/Max temp (based on advertised values in manual)</li> <li>Add <code>as_dict</code> to allow for serialization</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Target temp will expect and handle Fahrenheit if <code>use_metric</code> is False</li> </ul>"},{"location":"changelog/#090---2024-01-25","title":"[0.9.0] - 2024-01-25","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Detect model from advertiser data (Hopefully correctly)</li> <li>Colour, capacity and model numbers</li> <li>Handle Tumbler</li> <li>Rename \"Unknown\" state to \"Standby\"</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Bumped minimum version of bleak to 0.21.0</li> <li>Discover method changed to use advertisement information</li> <li><code>set_device</code> method replaced by <code>ble_event_callback</code> and it now also updated model info if not yet set.</li> <li><code>model</code> renamed to <code>model_info</code></li> <li><code>include_extra</code> option removed. <code>debug</code> has a similar function now.</li> </ul>"},{"location":"changelog/#083---2023-10-31","title":"[0.8.3] - 2023-10-31","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Set proper version and rebuild release</li> </ul>"},{"location":"changelog/#082---2023-10-31","title":"[0.8.2] - 2023-10-31","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Tests for Python 3.12</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Use debug level for connection timeout logger instead or error</li> </ul>"},{"location":"changelog/#081---2023-10-25","title":"[0.8.1] - 2023-10-25","text":""},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Use debug level for disconnect callback instead of warning</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Don't require adapter keyword for other backends</li> </ul>"},{"location":"changelog/#080---2023-10-25","title":"[0.8.0] - 2023-10-25","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Added support for Travel Mug 2</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Updated minimal dependencies</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>Dropped support for Python 3.9 as it is no longer supported by bleak-retry-connector and Home Assistant</li> </ul>"},{"location":"changelog/#070---2023-05-21","title":"[0.7.0] - 2023-05-21","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Added support for Travel Mug</li> <li>Added debugger to dump characteristics and their values for debugging</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Allow Travel Mug to be detected with shortened Bluetooth name</li> <li>Exclude led_colour attributes from the Travel Mug</li> <li>Add volume_level attribute for Travel Mug</li> <li>Make terms more generic as all devices are not Mugs</li> </ul>"},{"location":"changelog/#062---2023-04-14","title":"[0.6.2] - 2023-04-14","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Added attributes to differentiate between device types</li> <li>Don't fetch name for the Ember \"Cup\" as it doesn't have it</li> <li>In theory the \"Cup\" should be supported</li> </ul>"},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>The model attribute of the data is now a Model class that provides attributes based on model</li> </ul>"},{"location":"changelog/#061---2023-04-13","title":"[0.6.1] - 2023-04-13","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Discover Cups and Travel Mugs, but they are still not fully supported</li> <li>Debug option to print services and characteristics for debugging</li> </ul>"},{"location":"changelog/#060---2023-02-18","title":"[0.6.0] - 2023-02-18","text":""},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>EmberMugConnection changed to EmberMug</li> <li>EmberMug changed to MugData</li> <li>Made ensure_connection private and call it automatically in most cases</li> <li>Log if disconnect was expected or not</li> </ul>"},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Lock for operations to ensure only one at a time</li> <li>_ensure_connection now called before every write and before bulk reads</li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Changed condition that caused connections to be constantly reestablished because is_connected is not a bool.</li> <li>Don't call disconnect in disconnect callback</li> </ul>"},{"location":"changelog/#056---2023-02-08","title":"[0.5.6] - 2023-02-08","text":""},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Set proper attribute for on charging base</li> </ul>"},{"location":"changelog/#changed_10","title":"Changed","text":"<ul> <li>Update pre-commit, pytest and add dependabot</li> <li>register callback stores a dict to avoid duplicate registrations</li> </ul>"},{"location":"changelog/#055---2023-02-03","title":"[0.5.5] - 2023-02-03","text":""},{"location":"changelog/#changed_11","title":"Changed","text":"<ul> <li>Set values on mug immediately after setting them</li> <li>Only add/remove callback if not already done</li> </ul>"},{"location":"changelog/#054---2023-02-02","title":"[0.5.4] - 2023-02-02","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>More logging for different methods</li> </ul>"},{"location":"changelog/#changed_12","title":"Changed","text":"<ul> <li>Bump bleak to &gt;=0.19.5 for Home Assistant 2023.2</li> <li>Catch exceptions on querying DSK and UDSK and return empty strings</li> <li>No longer query \"extra\" attributes unless <code>include_extra=True</code> was passed to mug</li> </ul>"},{"location":"changelog/#053---2023-01-18","title":"[0.5.3] - 2023-01-18","text":""},{"location":"changelog/#changed_13","title":"Changed","text":"<ul> <li>Changed UUIDs, PushEvent IDs, LiquidState and TemperatureUnit to Enum</li> <li>TemperatureUnit changed to include degree symbol to match with Home Assistant</li> </ul>"},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>Added _read and_write helper methods with logging</li> </ul>"},{"location":"changelog/#052---2023-01-17","title":"[0.5.2] - 2023-01-17","text":""},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Fixed logging</li> </ul>"},{"location":"changelog/#051---2023-01-14","title":"[0.5.1] - 2023-01-14","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li>as_dict() for dumping Mug info</li> <li>More tests</li> </ul>"},{"location":"changelog/#changed_14","title":"Changed","text":"<ul> <li>Allow unit with or without degree and handle Enum for Home Assistant in set_temperature_unit()</li> <li>Remove <code>metric</code> attribute, it was supposed to be <code>use_metric</code></li> </ul>"},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>Fixed <code>_device</code> attribute which would not be updated on callback</li> </ul>"},{"location":"changelog/#050---2023-01-11","title":"[0.5.0] - 2023-01-11","text":""},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li>More tests for cli interface</li> <li>Add tests for Python 3.11</li> </ul>"},{"location":"changelog/#removed_2","title":"Removed","text":"<ul> <li>Automatic tests on macOS and Windows. They should still work though.</li> </ul>"},{"location":"changelog/#changed_15","title":"Changed","text":"<ul> <li>Update bleak and bleak-retry-connector to get retry decorator and match home assistant 2023.1</li> <li>Update documentation</li> <li>Updated linting and CI tools</li> </ul>"},{"location":"changelog/#042---2022-11-23","title":"[0.4.2] - 2022-11-23","text":""},{"location":"changelog/#changed_16","title":"Changed","text":"<ul> <li>Also catch NotImplementedError when trying to pair. (Affects Home Assistant ESPHome proxies)</li> </ul>"},{"location":"changelog/#041---2022-11-04","title":"[0.4.1] - 2022-11-04","text":""},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>Format Colour as hex when printed (for CLI)</li> </ul>"},{"location":"changelog/#040---2022-11-03","title":"[0.4.0] - 2022-11-03","text":""},{"location":"changelog/#changed_17","title":"Changed","text":"<ul> <li>Improve documentation for setting values</li> </ul>"},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li>cli option to get specific attributes by name</li> <li>cli option to set attributes</li> <li>cli option to limit output</li> </ul>"},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>Column number calculation</li> </ul>"},{"location":"changelog/#037---2022-11-01","title":"[0.3.7] - 2022-11-01","text":""},{"location":"changelog/#fix","title":"Fix","text":"<ul> <li>Remove ensure_connection in update_initial and update_multiple because it causes timeouts and loops</li> </ul>"},{"location":"changelog/#changes","title":"Changes","text":"<ul> <li>Update docs to document procedure for writing attributes</li> </ul>"},{"location":"changelog/#036---2022-10-19","title":"[0.3.6] - 2022-10-19","text":""},{"location":"changelog/#fix_1","title":"Fix","text":"<ul> <li>Remove retry_bluetooth_connection_error...</li> </ul>"},{"location":"changelog/#035---2022-10-17","title":"[0.3.5] - 2022-10-17","text":""},{"location":"changelog/#fix_2","title":"Fix","text":"<ul> <li>Add fallback method for retry_bluetooth_connection_error to not break on patch.</li> </ul>"},{"location":"changelog/#034---2022-10-17","title":"[0.3.4] - 2022-10-17","text":""},{"location":"changelog/#added_13","title":"Added","text":"<ul> <li>Use retry_bluetooth_connection_error on update methods</li> </ul>"},{"location":"changelog/#033---2022-10-17","title":"[0.3.3] - 2022-10-17","text":""},{"location":"changelog/#fix_3","title":"Fix","text":"<ul> <li>Try to fetch services on initial connection to wake device</li> </ul>"},{"location":"changelog/#032---2022-10-12","title":"[0.3.2] - 2022-10-12","text":""},{"location":"changelog/#fix_4","title":"Fix","text":"<ul> <li>Try to fix, but also always catch encoding errors</li> </ul>"},{"location":"changelog/#031---2022-10-10","title":"[0.3.1] - 2022-10-10","text":""},{"location":"changelog/#fix_5","title":"Fix","text":"<ul> <li>Catch error decoding UDSK and log warning to avoid error setting up</li> </ul>"},{"location":"changelog/#030---2022-10-08","title":"[0.3.0] - 2022-10-08","text":""},{"location":"changelog/#added_14","title":"Added","text":"<ul> <li>Also packaged as CLI command to be used directly</li> <li>Add register_callback</li> <li>Fire callbacks in notifications and all updates</li> <li>Add set_device and pass to establish_connection</li> </ul>"},{"location":"changelog/#changed_18","title":"Changed","text":"<ul> <li>Update bleak-retry-connector to 1.17.1</li> <li>Update bleak to 0.17.0</li> <li>Renamed connect to ensure_connection</li> </ul>"},{"location":"changelog/#025---2022-09-18","title":"[0.2.5] - 2022-09-18","text":""},{"location":"changelog/#fixed_11","title":"Fixed","text":"<ul> <li>Catch EOFError during pair, which is not caught in bleak/dbus-next currently</li> </ul>"},{"location":"changelog/#024---2022-09-09","title":"[0.2.4] - 2022-09-09","text":""},{"location":"changelog/#added_15","title":"Added","text":"<ul> <li>Lots of tests</li> </ul>"},{"location":"changelog/#fixed_12","title":"Fixed","text":"<ul> <li>Typo in metric in print_changes</li> <li>Fix Name validation rules</li> <li>set_temperature_unit method name</li> </ul>"},{"location":"changelog/#023---2022-09-09","title":"[0.2.3] - 2022-09-09","text":""},{"location":"changelog/#added_16","title":"Added","text":"<ul> <li>Format information as table in CLI</li> <li>Print message with error instead of stack trace in cli if bleak error occurs in find/discover</li> </ul>"},{"location":"changelog/#fixed_13","title":"Fixed","text":"<ul> <li>Incorrect name for imperial CLI flag</li> </ul>"},{"location":"changelog/#022---2022-09-08","title":"[0.2.2] - 2022-09-08","text":""},{"location":"changelog/#fixed_14","title":"Fixed","text":"<ul> <li>Only try to disconnect if client is present</li> </ul>"},{"location":"changelog/#021---2022-09-08","title":"[0.2.1] - 2022-09-08","text":""},{"location":"changelog/#added_17","title":"Added","text":"<ul> <li>Tests for data, scanner, mug</li> <li>CLI flag for imperial units</li> </ul>"},{"location":"changelog/#fixed_15","title":"Fixed","text":"<ul> <li>meta_display was not property</li> <li>target_temp returned current_temp</li> <li>extra flag was not applied to polling</li> </ul>"},{"location":"changelog/#020---2022-09-06","title":"[0.2.0] - 2022-09-06","text":""},{"location":"changelog/#added_18","title":"Added","text":"<ul> <li>bleak-retry-connector to help connect and maintain connection to mug</li> <li>Add option to show/hide less useful mug info</li> <li>Formatting for polled changes in CLI</li> <li>Add more tests</li> </ul>"},{"location":"changelog/#removed_3","title":"Removed","text":"<ul> <li>Support for python 3.8 - In order to use bleak-retry-connector</li> </ul>"},{"location":"changelog/#012---2022-09-03","title":"[0.1.2] - 2022-09-03","text":""},{"location":"changelog/#added_19","title":"Added","text":"<ul> <li>Add adapter param to EmberMugConnection and scanners (for BlueZ only)</li> <li>Add mac params to discover and find methods</li> <li>Decode udsk and mug id. Even if the values aren't super useful.</li> </ul>"},{"location":"changelog/#fixed_16","title":"Fixed","text":"<ul> <li>Improve CLI interface and gracefully handle no options provided</li> </ul>"},{"location":"changelog/#011---2022-09-03","title":"[0.1.1] - 2022-09-03","text":"<ul> <li>Bump version because of issues with name conflicts</li> <li>Fix GitHub Actions issues with Poetry</li> </ul>"},{"location":"changelog/#010---2022-08-26","title":"[0.1.0] - 2022-08-26","text":"<ul> <li>First release on PyPI test.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/sopelj/python-ember-mug/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>Python Ember Mug could always use more documentation, whether as part of the official Python Ember Mug docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/sopelj/python-ember-mug/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started","text":"<p>Ready to contribute? Here's how to set up <code>python-ember-mug</code> for local development.</p> <ol> <li>Fork the <code>python-ember-mug</code> repo on GitHub.</li> <li> <p>Clone your fork locally</p> <pre><code>git clone git@github.com:your_name_here/python-ember-mug.git\n</code></pre> </li> <li> <p>Ensure hatch is installed.</p> </li> <li> <p>You can directly run the CLI from hatch with:</p> <pre><code>hatch run ember-mug --help\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass the    tests, including testing other Python versions, with Hatch:</p> <pre><code>hatch run test:cov\n</code></pre> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>git add .\ngit commit -m \"Your detailed description of your changes.\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put    your new functionality into a function with a docstring, and add the    feature to the list in README.md.</li> <li>The pull request should work for Python 3.9, 3.10 and 3.11. Check    https://github.com/sopelj/python-ember-mug/actions    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"contributing/#tips","title":"Tips","text":"<pre><code>hatch run test:cov tests/test_python_ember_mug.py\n</code></pre> <p>To run a subset of tests.</p>"},{"location":"contributing/#deploying","title":"Deploying","text":"<p>A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run:</p> <pre><code>hatch version patch # possible: major / minor / patch\ngit add .\ngit commit -m \"Bump version: v$(hatch version)\"\ngit tag \"v$(hatch version)\"\ngit push\ngit push --tags\n</code></pre> <p>GitHub Actions will then deploy to PyPI if tests pass.</p>"},{"location":"api/SUMMARY/","title":"SUMMARY","text":"<ul> <li>cli.py<ul> <li>commands.py</li> <li>helpers.py</li> </ul> </li> <li>consts.py</li> <li>data.py</li> <li>formatting.py</li> <li>mug.py</li> <li>scanner.py</li> <li>utils.py</li> </ul>"},{"location":"api/consts/","title":"consts","text":""},{"location":"api/consts/#consts","title":"consts","text":"<p>Bluetooth UUIDs and other constants used for communicating with the mug.</p>"},{"location":"api/consts/#consts-attributes","title":"Attributes","text":""},{"location":"api/consts/#consts.ATTR_LABELS","title":"ATTR_LABELS  <code>module-attribute</code>","text":"<pre><code>ATTR_LABELS = {\n    \"name\": \"Device Name\",\n    \"meta\": \"Meta\",\n    \"battery\": \"Battery\",\n    \"firmware\": \"Firmware\",\n    \"led_colour\": \"LED Colour\",\n    \"liquid_state\": \"Liquid State\",\n    \"liquid_level\": \"Liquid Level\",\n    \"current_temp\": \"Current Temp\",\n    \"target_temp\": \"Target Temp\",\n    \"use_metric\": \"Use Metric\",\n    \"dsk\": \"DSK\",\n    \"udsk\": \"UDSK\",\n    \"date_time_zone\": \"Date Time + Time Zone\",\n    \"battery_voltage\": \"Voltage\",\n    \"volume_level\": \"Volume Level\",\n}\n</code></pre>"},{"location":"api/consts/#consts.DEFAULT_NAME","title":"DEFAULT_NAME  <code>module-attribute</code>","text":"<pre><code>DEFAULT_NAME = 'Ember Device'\n</code></pre>"},{"location":"api/consts/#consts.DEVICE_MODEL_NAMES","title":"DEVICE_MODEL_NAMES  <code>module-attribute</code>","text":"<pre><code>DEVICE_MODEL_NAMES: dict[consts.DeviceModel, str] = {\n    consts.DeviceModel.CUP_6_OZ: \"Ember Cup\",\n    consts.DeviceModel.MUG_1_10_OZ: \"Ember Mug (10oz)\",\n    consts.DeviceModel.MUG_1_14_OZ: \"Ember Mug (14oz)\",\n    consts.DeviceModel.MUG_2_10_OZ: \"Ember Mug 2 (10oz)\",\n    consts.DeviceModel.MUG_2_14_OZ: \"Ember Mug 2 (14oz)\",\n    consts.DeviceModel.TRAVEL_MUG_12_OZ: \"Ember Travel Mug\",\n    consts.DeviceModel.TUMBLER_16_OZ: \"Ember Tumbler\",\n}\n</code></pre>"},{"location":"api/consts/#consts.DEVICE_SERVICE_UUIDS","title":"DEVICE_SERVICE_UUIDS  <code>module-attribute</code>","text":"<pre><code>DEVICE_SERVICE_UUIDS = [\n    str(consts.MugCharacteristic.STANDARD_SERVICE),\n    *consts.TRAVEL_MUG_SERVICE_UUIDS,\n]\n</code></pre>"},{"location":"api/consts/#consts.EMBER_BLE_SIG","title":"EMBER_BLE_SIG  <code>module-attribute</code>","text":"<pre><code>EMBER_BLE_SIG = 961\n</code></pre>"},{"location":"api/consts/#consts.EXTRA_ATTRS","title":"EXTRA_ATTRS  <code>module-attribute</code>","text":"<pre><code>EXTRA_ATTRS = {\n    \"battery_voltage\",\n    \"date_time_zone\",\n    \"udsk\",\n    \"dsk\",\n}\n</code></pre>"},{"location":"api/consts/#consts.INITIAL_ATTRS","title":"INITIAL_ATTRS  <code>module-attribute</code>","text":"<pre><code>INITIAL_ATTRS = {\n    \"meta\",\n    \"udsk\",\n    \"dsk\",\n    \"date_time_zone\",\n    \"firmware\",\n}\n</code></pre>"},{"location":"api/consts/#consts.IS_LINUX","title":"IS_LINUX  <code>module-attribute</code>","text":"<pre><code>IS_LINUX = platform.system() == 'Linux'\n</code></pre>"},{"location":"api/consts/#consts.LIQUID_STATE_LABELS","title":"LIQUID_STATE_LABELS  <code>module-attribute</code>","text":"<pre><code>LIQUID_STATE_LABELS: dict[int, str] = {\n    consts.LiquidState.STANDBY: \"Standby\",\n    consts.LiquidState.EMPTY: \"Empty\",\n    consts.LiquidState.FILLING: \"Filling\",\n    consts.LiquidState.COLD_NO_TEMP_CONTROL: \"Cold (No control)\",\n    consts.LiquidState.COOLING: \"Cooling\",\n    consts.LiquidState.HEATING: \"Heating\",\n    consts.LiquidState.TARGET_TEMPERATURE: \"Perfect\",\n    consts.LiquidState.WARM_NO_TEMP_CONTROL: \"Warm (No control)\",\n}\n</code></pre>"},{"location":"api/consts/#consts.LIQUID_STATE_UNKNOWN","title":"LIQUID_STATE_UNKNOWN  <code>module-attribute</code>","text":"<pre><code>LIQUID_STATE_UNKNOWN = 'Unknown'\n</code></pre>"},{"location":"api/consts/#consts.MAC_ADDRESS_REGEX","title":"MAC_ADDRESS_REGEX  <code>module-attribute</code>","text":"<pre><code>MAC_ADDRESS_REGEX = re.compile(\n    \"^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$\"\n)\n</code></pre>"},{"location":"api/consts/#consts.MIN_MAX_TEMPS","title":"MIN_MAX_TEMPS  <code>module-attribute</code>","text":"<pre><code>MIN_MAX_TEMPS = {\n    consts.TemperatureUnit.CELSIUS: consts.MinMaxTemp(\n        49, 63\n    ),\n    consts.TemperatureUnit.FAHRENHEIT: consts.MinMaxTemp(\n        120, 145\n    ),\n}\n</code></pre>"},{"location":"api/consts/#consts.MUG_NAME_PATTERN","title":"MUG_NAME_PATTERN  <code>module-attribute</code>","text":"<pre><code>MUG_NAME_PATTERN = consts.MUG_NAME_REGEX.pattern\n</code></pre>"},{"location":"api/consts/#consts.MUG_NAME_REGEX","title":"MUG_NAME_REGEX  <code>module-attribute</code>","text":"<pre><code>MUG_NAME_REGEX = re.compile(\n    \"^[A-Za-z0-9,.\\\\[\\\\]#()!\\\\\\\"\\\\';:|\\\\-_+&lt;&gt;%= ]{1,16}$\"\n)\n</code></pre>"},{"location":"api/consts/#consts.PUSH_EVENT_BATTERY_IDS","title":"PUSH_EVENT_BATTERY_IDS  <code>module-attribute</code>","text":"<pre><code>PUSH_EVENT_BATTERY_IDS = [\n    consts.PushEvent.BATTERY_CHANGED,\n    consts.PushEvent.CHARGER_CONNECTED,\n    consts.PushEvent.CHARGER_DISCONNECTED,\n]\n</code></pre>"},{"location":"api/consts/#consts.TRAVEL_MUG_SERVICE_UUIDS","title":"TRAVEL_MUG_SERVICE_UUIDS  <code>module-attribute</code>","text":"<pre><code>TRAVEL_MUG_SERVICE_UUIDS = (\n    str(consts.MugCharacteristic.TRAVEL_MUG_SERVICE),\n    str(consts.MugCharacteristic.TRAVEL_MUG_SERVICE_OTHER),\n)\n</code></pre>"},{"location":"api/consts/#consts.UPDATE_ATTRS","title":"UPDATE_ATTRS  <code>module-attribute</code>","text":"<pre><code>UPDATE_ATTRS = {\n    \"name\",\n    \"led_colour\",\n    \"current_temp\",\n    \"target_temp\",\n    \"temperature_unit\",\n    \"battery\",\n    \"liquid_level\",\n    \"liquid_state\",\n}\n</code></pre>"},{"location":"api/consts/#consts.UUID_TEMPLATE","title":"UUID_TEMPLATE  <code>module-attribute</code>","text":"<pre><code>UUID_TEMPLATE = 'fc54{:0&gt;4x}-236c-4c94-8fa9-944a3e5353fa'\n</code></pre>"},{"location":"api/consts/#consts-classes","title":"Classes","text":""},{"location":"api/consts/#consts.DeviceColour","title":"DeviceColour","text":"<p>               Bases: <code>str</code>, <code>enum.Enum</code></p> <p>All colours possible found across models.</p> Source code in <code>ember_mug/consts.py</code> <pre><code>class DeviceColour(str, Enum):\n    \"\"\"All colours possible found across models.\"\"\"\n\n    SAGE_GREEN = \"Sage Green\"\n    SANDSTONE = \"Sandstone\"\n    BLACK = \"Black\"\n    WHITE = \"White\"\n    GREY = \"Grey\"\n    BLUE = \"Blue\"\n    RED = \"Red\"\n    COPPER = \"Copper\"\n    GOLD = \"Gold\"\n    STAINLESS_STEEL = \"Stainless Steel\"\n    ROSE_GOLD = \"Rose Gold\"\n</code></pre>"},{"location":"api/consts/#consts.DeviceColour-attributes","title":"Attributes","text":""},{"location":"api/consts/#consts.DeviceColour.BLACK","title":"BLACK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BLACK = 'Black'\n</code></pre>"},{"location":"api/consts/#consts.DeviceColour.BLUE","title":"BLUE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BLUE = 'Blue'\n</code></pre>"},{"location":"api/consts/#consts.DeviceColour.COPPER","title":"COPPER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>COPPER = 'Copper'\n</code></pre>"},{"location":"api/consts/#consts.DeviceColour.GOLD","title":"GOLD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GOLD = 'Gold'\n</code></pre>"},{"location":"api/consts/#consts.DeviceColour.GREY","title":"GREY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GREY = 'Grey'\n</code></pre>"},{"location":"api/consts/#consts.DeviceColour.RED","title":"RED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RED = 'Red'\n</code></pre>"},{"location":"api/consts/#consts.DeviceColour.ROSE_GOLD","title":"ROSE_GOLD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ROSE_GOLD = 'Rose Gold'\n</code></pre>"},{"location":"api/consts/#consts.DeviceColour.SAGE_GREEN","title":"SAGE_GREEN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SAGE_GREEN = 'Sage Green'\n</code></pre>"},{"location":"api/consts/#consts.DeviceColour.SANDSTONE","title":"SANDSTONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SANDSTONE = 'Sandstone'\n</code></pre>"},{"location":"api/consts/#consts.DeviceColour.STAINLESS_STEEL","title":"STAINLESS_STEEL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STAINLESS_STEEL = 'Stainless Steel'\n</code></pre>"},{"location":"api/consts/#consts.DeviceColour.WHITE","title":"WHITE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WHITE = 'White'\n</code></pre>"},{"location":"api/consts/#consts.DeviceModel","title":"DeviceModel","text":"<p>               Bases: <code>str</code>, <code>enum.Enum</code></p> <p>Know device models.</p> Source code in <code>ember_mug/consts.py</code> <pre><code>class DeviceModel(str, Enum):\n    \"\"\"Know device models.\"\"\"\n\n    CUP_6_OZ = \"CM21S\"\n    MUG_1_10_OZ = \"CM17\"\n    MUG_1_14_OZ = \"CM17P\"\n    MUG_2_10_OZ = \"CM19/CM21M\"\n    MUG_2_14_OZ = \"CM19P/CM21L\"\n    TRAVEL_MUG_12_OZ = \"TM19\"\n    TUMBLER_16_OZ = \"CM21XL\"\n    UNKNOWN_DEVICE = \"Unknown\"\n</code></pre>"},{"location":"api/consts/#consts.DeviceModel-attributes","title":"Attributes","text":""},{"location":"api/consts/#consts.DeviceModel.CUP_6_OZ","title":"CUP_6_OZ  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CUP_6_OZ = 'CM21S'\n</code></pre>"},{"location":"api/consts/#consts.DeviceModel.MUG_1_10_OZ","title":"MUG_1_10_OZ  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MUG_1_10_OZ = 'CM17'\n</code></pre>"},{"location":"api/consts/#consts.DeviceModel.MUG_1_14_OZ","title":"MUG_1_14_OZ  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MUG_1_14_OZ = 'CM17P'\n</code></pre>"},{"location":"api/consts/#consts.DeviceModel.MUG_2_10_OZ","title":"MUG_2_10_OZ  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MUG_2_10_OZ = 'CM19/CM21M'\n</code></pre>"},{"location":"api/consts/#consts.DeviceModel.MUG_2_14_OZ","title":"MUG_2_14_OZ  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MUG_2_14_OZ = 'CM19P/CM21L'\n</code></pre>"},{"location":"api/consts/#consts.DeviceModel.TRAVEL_MUG_12_OZ","title":"TRAVEL_MUG_12_OZ  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TRAVEL_MUG_12_OZ = 'TM19'\n</code></pre>"},{"location":"api/consts/#consts.DeviceModel.TUMBLER_16_OZ","title":"TUMBLER_16_OZ  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TUMBLER_16_OZ = 'CM21XL'\n</code></pre>"},{"location":"api/consts/#consts.DeviceModel.UNKNOWN_DEVICE","title":"UNKNOWN_DEVICE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNKNOWN_DEVICE = 'Unknown'\n</code></pre>"},{"location":"api/consts/#consts.DeviceType","title":"DeviceType","text":"<p>               Bases: <code>str</code>, <code>enum.Enum</code></p> <p>Base device types.</p> Source code in <code>ember_mug/consts.py</code> <pre><code>class DeviceType(str, Enum):\n    \"\"\"Base device types.\"\"\"\n\n    CUP = \"cup\"\n    MUG = \"mug\"\n    TRAVEL_MUG = \"travel_mug\"\n    TUMBLER = \"tumbler\"\n</code></pre>"},{"location":"api/consts/#consts.DeviceType-attributes","title":"Attributes","text":""},{"location":"api/consts/#consts.DeviceType.CUP","title":"CUP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CUP = 'cup'\n</code></pre>"},{"location":"api/consts/#consts.DeviceType.MUG","title":"MUG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MUG = 'mug'\n</code></pre>"},{"location":"api/consts/#consts.DeviceType.TRAVEL_MUG","title":"TRAVEL_MUG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TRAVEL_MUG = 'travel_mug'\n</code></pre>"},{"location":"api/consts/#consts.DeviceType.TUMBLER","title":"TUMBLER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TUMBLER = 'tumbler'\n</code></pre>"},{"location":"api/consts/#consts.LiquidState","title":"LiquidState","text":"<p>               Bases: <code>enum.IntEnum</code></p> <p>Constants for liquid state codes.</p> Source code in <code>ember_mug/consts.py</code> <pre><code>class LiquidState(IntEnum):\n    \"\"\"Constants for liquid state codes.\"\"\"\n\n    STANDBY = 0\n    EMPTY = 1\n    FILLING = 2\n    COLD_NO_TEMP_CONTROL = 3\n    COOLING = 4\n    HEATING = 5\n    TARGET_TEMPERATURE = 6\n    WARM_NO_TEMP_CONTROL = 7\n\n    @cached_property\n    def label(self) -&gt; str:\n        \"\"\"Get label for current state.\"\"\"\n        return LIQUID_STATE_LABELS[self.value]\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return label for display.\"\"\"\n        return self.label\n</code></pre>"},{"location":"api/consts/#consts.LiquidState-attributes","title":"Attributes","text":""},{"location":"api/consts/#consts.LiquidState.COLD_NO_TEMP_CONTROL","title":"COLD_NO_TEMP_CONTROL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>COLD_NO_TEMP_CONTROL = 3\n</code></pre>"},{"location":"api/consts/#consts.LiquidState.COOLING","title":"COOLING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>COOLING = 4\n</code></pre>"},{"location":"api/consts/#consts.LiquidState.EMPTY","title":"EMPTY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EMPTY = 1\n</code></pre>"},{"location":"api/consts/#consts.LiquidState.FILLING","title":"FILLING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FILLING = 2\n</code></pre>"},{"location":"api/consts/#consts.LiquidState.HEATING","title":"HEATING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HEATING = 5\n</code></pre>"},{"location":"api/consts/#consts.LiquidState.STANDBY","title":"STANDBY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STANDBY = 0\n</code></pre>"},{"location":"api/consts/#consts.LiquidState.TARGET_TEMPERATURE","title":"TARGET_TEMPERATURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TARGET_TEMPERATURE = 6\n</code></pre>"},{"location":"api/consts/#consts.LiquidState.WARM_NO_TEMP_CONTROL","title":"WARM_NO_TEMP_CONTROL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WARM_NO_TEMP_CONTROL = 7\n</code></pre>"},{"location":"api/consts/#consts.LiquidState.label","title":"label  <code>cached</code> <code>property</code>","text":"<pre><code>label: str\n</code></pre> <p>Get label for current state.</p>"},{"location":"api/consts/#consts.MinMaxTemp","title":"MinMaxTemp","text":"<p>               Bases: <code>typing.NamedTuple</code></p> <p>Helper for MinMaxTemp.</p> Source code in <code>ember_mug/consts.py</code> <pre><code>class MinMaxTemp(NamedTuple):\n    \"\"\"Helper for MinMaxTemp.\"\"\"\n\n    min_temp: float\n    max_temp: float\n</code></pre>"},{"location":"api/consts/#consts.MinMaxTemp-attributes","title":"Attributes","text":""},{"location":"api/consts/#consts.MinMaxTemp.max_temp","title":"max_temp  <code>instance-attribute</code>","text":"<pre><code>max_temp: float\n</code></pre>"},{"location":"api/consts/#consts.MinMaxTemp.min_temp","title":"min_temp  <code>instance-attribute</code>","text":"<pre><code>min_temp: float\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic","title":"MugCharacteristic","text":"<p>               Bases: <code>enum.IntEnum</code></p> <p>Characteristic IDs for the Mug.</p> Source code in <code>ember_mug/consts.py</code> <pre><code>class MugCharacteristic(IntEnum):\n    \"\"\"Characteristic IDs for the Mug.\"\"\"\n\n    # Name of mug in byte string (Read/Write)\n    MUG_NAME = 1\n    # Current Mug Temp (Read)\n    CURRENT_TEMPERATURE = 2\n    # Target Mug Temp (Read/Write)\n    TARGET_TEMPERATURE = 3\n    # Unit (0 -&gt; Celsius, 1 -&gt; Fahrenheit) (Read/Write)\n    TEMPERATURE_UNIT = 4\n    # Level (Between 0 -&gt; 30 ?) 30 100% ?\n    LIQUID_LEVEL = 5\n    # Current date and time zone? (Read/Write)\n    DATE_TIME_AND_ZONE = 6\n    # Battery Info (Read)\n    BATTERY = 7\n    # Integer representing what it is doing with the liquid (Read)\n    LIQUID_STATE = 8\n    # Volume - I think for the thermos\n    VOLUME = 9\n    # Last location - (Write)\n    LAST_LOCATION = 10\n    # Unsure what it does\n    UUID_ACCELERATION = 11\n    # Firmware info (Read)\n    FIRMWARE = 12\n    # [Unique ID]-[serial number] (Read)\n    MUG_ID = 13\n    # DSK - Unique ID used for auth in app (Read)\n    DSK = 14\n    # UDSK - Used for auth in app (Read/Write)\n    UDSK = 15\n    # int/temp lock - Address (Read/Write)\n    CONTROL_REGISTER_ADDRESS = 16\n    # Battery charge info (Read/Write)\n    CONTROL_REGISTER_DATA = 17\n    # To watch for changes from mug (Notify/Read)\n    PUSH_EVENT = 18\n    # To gather bytes from mug for stats (Notify)\n    STATISTICS = 19\n    # RGBA Colour of LED (Read/Write)\n    LED = 20\n    # Service\n    STANDARD_SERVICE = 13858\n    TRAVEL_MUG_SERVICE = 13857\n    TRAVEL_MUG_SERVICE_OTHER = 8609\n\n    @cached_property\n    def uuid(self) -&gt; UUID:\n        \"\"\"Convert the ID to a full UUID and cache.\"\"\"\n        return UUID(UUID_TEMPLATE.format(self.value))\n\n    def __str__(self) -&gt; str:\n        \"\"\"Convert UUID to string value.\"\"\"\n        return str(self.uuid)\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic-attributes","title":"Attributes","text":""},{"location":"api/consts/#consts.MugCharacteristic.BATTERY","title":"BATTERY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BATTERY = 7\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.CONTROL_REGISTER_ADDRESS","title":"CONTROL_REGISTER_ADDRESS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONTROL_REGISTER_ADDRESS = 16\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.CONTROL_REGISTER_DATA","title":"CONTROL_REGISTER_DATA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONTROL_REGISTER_DATA = 17\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.CURRENT_TEMPERATURE","title":"CURRENT_TEMPERATURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CURRENT_TEMPERATURE = 2\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.DATE_TIME_AND_ZONE","title":"DATE_TIME_AND_ZONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DATE_TIME_AND_ZONE = 6\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.DSK","title":"DSK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DSK = 14\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.FIRMWARE","title":"FIRMWARE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FIRMWARE = 12\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.LAST_LOCATION","title":"LAST_LOCATION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LAST_LOCATION = 10\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.LED","title":"LED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LED = 20\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.LIQUID_LEVEL","title":"LIQUID_LEVEL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LIQUID_LEVEL = 5\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.LIQUID_STATE","title":"LIQUID_STATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LIQUID_STATE = 8\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.MUG_ID","title":"MUG_ID  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MUG_ID = 13\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.MUG_NAME","title":"MUG_NAME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MUG_NAME = 1\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.PUSH_EVENT","title":"PUSH_EVENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PUSH_EVENT = 18\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.STANDARD_SERVICE","title":"STANDARD_SERVICE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STANDARD_SERVICE = 13858\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.STATISTICS","title":"STATISTICS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STATISTICS = 19\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.TARGET_TEMPERATURE","title":"TARGET_TEMPERATURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TARGET_TEMPERATURE = 3\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.TEMPERATURE_UNIT","title":"TEMPERATURE_UNIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TEMPERATURE_UNIT = 4\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.TRAVEL_MUG_SERVICE","title":"TRAVEL_MUG_SERVICE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TRAVEL_MUG_SERVICE = 13857\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.TRAVEL_MUG_SERVICE_OTHER","title":"TRAVEL_MUG_SERVICE_OTHER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TRAVEL_MUG_SERVICE_OTHER = 8609\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.UDSK","title":"UDSK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UDSK = 15\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.UUID_ACCELERATION","title":"UUID_ACCELERATION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UUID_ACCELERATION = 11\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.VOLUME","title":"VOLUME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VOLUME = 9\n</code></pre>"},{"location":"api/consts/#consts.MugCharacteristic.uuid","title":"uuid  <code>cached</code> <code>property</code>","text":"<pre><code>uuid: uuid.UUID\n</code></pre> <p>Convert the ID to a full UUID and cache.</p>"},{"location":"api/consts/#consts.PushEvent","title":"PushEvent","text":"<p>               Bases: <code>enum.IntEnum</code></p> <p>IDs for Push Events.</p> Source code in <code>ember_mug/consts.py</code> <pre><code>class PushEvent(IntEnum):\n    \"\"\"IDs for Push Events.\"\"\"\n\n    BATTERY_CHANGED = 1\n    CHARGER_CONNECTED = 2\n    CHARGER_DISCONNECTED = 3\n    TARGET_TEMPERATURE_CHANGED = 4\n    DRINK_TEMPERATURE_CHANGED = 5\n    AUTH_INFO_NOT_FOUND = 6\n    LIQUID_LEVEL_CHANGED = 7\n    LIQUID_STATE_CHANGED = 8\n    BATTERY_VOLTAGE_STATE_CHANGED = 9\n</code></pre>"},{"location":"api/consts/#consts.PushEvent-attributes","title":"Attributes","text":""},{"location":"api/consts/#consts.PushEvent.AUTH_INFO_NOT_FOUND","title":"AUTH_INFO_NOT_FOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AUTH_INFO_NOT_FOUND = 6\n</code></pre>"},{"location":"api/consts/#consts.PushEvent.BATTERY_CHANGED","title":"BATTERY_CHANGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BATTERY_CHANGED = 1\n</code></pre>"},{"location":"api/consts/#consts.PushEvent.BATTERY_VOLTAGE_STATE_CHANGED","title":"BATTERY_VOLTAGE_STATE_CHANGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BATTERY_VOLTAGE_STATE_CHANGED = 9\n</code></pre>"},{"location":"api/consts/#consts.PushEvent.CHARGER_CONNECTED","title":"CHARGER_CONNECTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHARGER_CONNECTED = 2\n</code></pre>"},{"location":"api/consts/#consts.PushEvent.CHARGER_DISCONNECTED","title":"CHARGER_DISCONNECTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHARGER_DISCONNECTED = 3\n</code></pre>"},{"location":"api/consts/#consts.PushEvent.DRINK_TEMPERATURE_CHANGED","title":"DRINK_TEMPERATURE_CHANGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DRINK_TEMPERATURE_CHANGED = 5\n</code></pre>"},{"location":"api/consts/#consts.PushEvent.LIQUID_LEVEL_CHANGED","title":"LIQUID_LEVEL_CHANGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LIQUID_LEVEL_CHANGED = 7\n</code></pre>"},{"location":"api/consts/#consts.PushEvent.LIQUID_STATE_CHANGED","title":"LIQUID_STATE_CHANGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LIQUID_STATE_CHANGED = 8\n</code></pre>"},{"location":"api/consts/#consts.PushEvent.TARGET_TEMPERATURE_CHANGED","title":"TARGET_TEMPERATURE_CHANGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TARGET_TEMPERATURE_CHANGED = 4\n</code></pre>"},{"location":"api/consts/#consts.TemperatureUnit","title":"TemperatureUnit","text":"<p>               Bases: <code>str</code>, <code>enum.Enum</code></p> <p>Temperature Units.</p> Source code in <code>ember_mug/consts.py</code> <pre><code>class TemperatureUnit(str, Enum):\n    \"\"\"Temperature Units.\"\"\"\n\n    CELSIUS = \"\u00b0C\"\n    FAHRENHEIT = \"\u00b0F\"\n</code></pre>"},{"location":"api/consts/#consts.TemperatureUnit-attributes","title":"Attributes","text":""},{"location":"api/consts/#consts.TemperatureUnit.CELSIUS","title":"CELSIUS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CELSIUS = '\u00b0C'\n</code></pre>"},{"location":"api/consts/#consts.TemperatureUnit.FAHRENHEIT","title":"FAHRENHEIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FAHRENHEIT = '\u00b0F'\n</code></pre>"},{"location":"api/consts/#consts.VolumeLevel","title":"VolumeLevel","text":"<p>               Bases: <code>str</code>, <code>enum.Enum</code></p> <p>Class to manage volume levels.</p> Source code in <code>ember_mug/consts.py</code> <pre><code>class VolumeLevel(str, Enum):\n    \"\"\"Class to manage volume levels.\"\"\"\n\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n\n    @classmethod\n    def from_state(cls, state: int) -&gt; VolumeLevel:\n        \"\"\"Build Volume level from int value.\"\"\"\n        return {0: cls.LOW, 1: cls.MEDIUM, 2: cls.HIGH}[state]\n\n    @cached_property\n    def state(self) -&gt; int:\n        \"\"\"Get int value from value.\"\"\"\n        return {self.LOW: 0, self.MEDIUM: 1, self.HIGH: 2}[self]\n</code></pre>"},{"location":"api/consts/#consts.VolumeLevel-attributes","title":"Attributes","text":""},{"location":"api/consts/#consts.VolumeLevel.HIGH","title":"HIGH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HIGH = 'high'\n</code></pre>"},{"location":"api/consts/#consts.VolumeLevel.LOW","title":"LOW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOW = 'low'\n</code></pre>"},{"location":"api/consts/#consts.VolumeLevel.MEDIUM","title":"MEDIUM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MEDIUM = 'medium'\n</code></pre>"},{"location":"api/consts/#consts.VolumeLevel.state","title":"state  <code>cached</code> <code>property</code>","text":"<pre><code>state: int\n</code></pre> <p>Get int value from value.</p>"},{"location":"api/consts/#consts.VolumeLevel-functions","title":"Functions","text":""},{"location":"api/consts/#consts.VolumeLevel.from_state","title":"from_state  <code>classmethod</code>","text":"<pre><code>from_state(state: int) -&gt; consts.VolumeLevel\n</code></pre> <p>Build Volume level from int value.</p> Source code in <code>ember_mug/consts.py</code> <pre><code>@classmethod\ndef from_state(cls, state: int) -&gt; VolumeLevel:\n    \"\"\"Build Volume level from int value.\"\"\"\n    return {0: cls.LOW, 1: cls.MEDIUM, 2: cls.HIGH}[state]\n</code></pre>"},{"location":"api/data/","title":"data","text":""},{"location":"api/data/#data","title":"data","text":"<p>Classes for representing data from the mug.</p>"},{"location":"api/data/#data-classes","title":"Classes","text":""},{"location":"api/data/#data.AsDict","title":"AsDict","text":"<p>Mixin to add as_dict to dataclass for serialization.</p> Source code in <code>ember_mug/data.py</code> <pre><code>class AsDict:\n    \"\"\"Mixin to add as_dict to dataclass for serialization.\"\"\"\n\n    def as_dict(self: DataclassInstance) -&gt; dict[str, Any]:\n        \"\"\"Add as_dict to dataclass for serialization.\"\"\"\n        return asdict(self)\n</code></pre>"},{"location":"api/data/#data.AsDict-functions","title":"Functions","text":""},{"location":"api/data/#data.AsDict.as_dict","title":"as_dict","text":"<pre><code>as_dict() -&gt; dict[str, typing.Any]\n</code></pre> <p>Add as_dict to dataclass for serialization.</p> Source code in <code>ember_mug/data.py</code> <pre><code>def as_dict(self: DataclassInstance) -&gt; dict[str, Any]:\n    \"\"\"Add as_dict to dataclass for serialization.\"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"api/data/#data.BaseModelInfo","title":"BaseModelInfo  <code>dataclass</code>","text":"<p>               Bases: <code>data.AsDict</code></p> <p>Base class to declare properties as field.</p> Source code in <code>ember_mug/data.py</code> <pre><code>@dataclass\nclass BaseModelInfo(AsDict):\n    \"\"\"Base class to declare properties as field.\"\"\"\n\n    model: DeviceModel | None = None\n    colour: DeviceColour | None = None\n    name: str = field(init=False)\n    capacity: int | None = field(init=False)\n    device_type: DeviceType = field(init=False)\n</code></pre>"},{"location":"api/data/#data.BaseModelInfo-attributes","title":"Attributes","text":""},{"location":"api/data/#data.BaseModelInfo.capacity","title":"capacity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>capacity: int | None = dataclasses.field(init=False)\n</code></pre>"},{"location":"api/data/#data.BaseModelInfo.colour","title":"colour  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>colour: data.consts.DeviceColour | None = None\n</code></pre>"},{"location":"api/data/#data.BaseModelInfo.device_type","title":"device_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>device_type: data.consts.DeviceType = dataclasses.field(\n    init=False\n)\n</code></pre>"},{"location":"api/data/#data.BaseModelInfo.model","title":"model  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model: data.consts.DeviceModel | None = None\n</code></pre>"},{"location":"api/data/#data.BaseModelInfo.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = dataclasses.field(init=False)\n</code></pre>"},{"location":"api/data/#data.BaseModelInfo-functions","title":"Functions","text":""},{"location":"api/data/#data.BaseModelInfo.as_dict","title":"as_dict","text":"<pre><code>as_dict() -&gt; dict[str, typing.Any]\n</code></pre> <p>Add as_dict to dataclass for serialization.</p> Source code in <code>ember_mug/data.py</code> <pre><code>def as_dict(self: DataclassInstance) -&gt; dict[str, Any]:\n    \"\"\"Add as_dict to dataclass for serialization.\"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"api/data/#data.BatteryInfo","title":"BatteryInfo  <code>dataclass</code>","text":"<p>               Bases: <code>data.AsDict</code></p> <p>Battery Information.</p> Source code in <code>ember_mug/data.py</code> <pre><code>@dataclass\nclass BatteryInfo(AsDict):\n    \"\"\"Battery Information.\"\"\"\n\n    percent: float\n    on_charging_base: bool\n\n    @classmethod\n    def from_bytes(cls, data: bytes) -&gt; BatteryInfo:\n        \"\"\"Initialize from raw bytes.\"\"\"\n        return cls(\n            percent=round(float(data[0]), 2),\n            on_charging_base=data[1] == 1,\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Format nicely for printing.\"\"\"\n        return f'{self.percent}%, {\"\" if self.on_charging_base else \"not \"}on charging base'\n</code></pre>"},{"location":"api/data/#data.BatteryInfo-attributes","title":"Attributes","text":""},{"location":"api/data/#data.BatteryInfo.on_charging_base","title":"on_charging_base  <code>instance-attribute</code>","text":"<pre><code>on_charging_base: bool\n</code></pre>"},{"location":"api/data/#data.BatteryInfo.percent","title":"percent  <code>instance-attribute</code>","text":"<pre><code>percent: float\n</code></pre>"},{"location":"api/data/#data.BatteryInfo-functions","title":"Functions","text":""},{"location":"api/data/#data.BatteryInfo.as_dict","title":"as_dict","text":"<pre><code>as_dict() -&gt; dict[str, typing.Any]\n</code></pre> <p>Add as_dict to dataclass for serialization.</p> Source code in <code>ember_mug/data.py</code> <pre><code>def as_dict(self: DataclassInstance) -&gt; dict[str, Any]:\n    \"\"\"Add as_dict to dataclass for serialization.\"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"api/data/#data.BatteryInfo.from_bytes","title":"from_bytes  <code>classmethod</code>","text":"<pre><code>from_bytes(data: bytes) -&gt; data.BatteryInfo\n</code></pre> <p>Initialize from raw bytes.</p> Source code in <code>ember_mug/data.py</code> <pre><code>@classmethod\ndef from_bytes(cls, data: bytes) -&gt; BatteryInfo:\n    \"\"\"Initialize from raw bytes.\"\"\"\n    return cls(\n        percent=round(float(data[0]), 2),\n        on_charging_base=data[1] == 1,\n    )\n</code></pre>"},{"location":"api/data/#data.Change","title":"Change","text":"<p>               Bases: <code>typing.NamedTuple</code></p> <p>Helper for storing changes to attributes.</p> Source code in <code>ember_mug/data.py</code> <pre><code>class Change(NamedTuple):\n    \"\"\"Helper for storing changes to attributes.\"\"\"\n\n    attr: str\n    old_value: Any\n    new_value: Any\n\n    def __str__(self) -&gt; str:\n        \"\"\"Use str to format Change message.\"\"\"\n        return f'{self.attr.replace(\"_\", \" \").title()} changed from \"{self.old_value}\" to \"{self.new_value}\"'\n</code></pre>"},{"location":"api/data/#data.Change-attributes","title":"Attributes","text":""},{"location":"api/data/#data.Change.attr","title":"attr  <code>instance-attribute</code>","text":"<pre><code>attr: str\n</code></pre>"},{"location":"api/data/#data.Change.new_value","title":"new_value  <code>instance-attribute</code>","text":"<pre><code>new_value: typing.Any\n</code></pre>"},{"location":"api/data/#data.Change.old_value","title":"old_value  <code>instance-attribute</code>","text":"<pre><code>old_value: typing.Any\n</code></pre>"},{"location":"api/data/#data.Colour","title":"Colour","text":"<p>               Bases: <code>typing.NamedTuple</code></p> <p>Simple helper for colour formatting.</p> Source code in <code>ember_mug/data.py</code> <pre><code>class Colour(NamedTuple):\n    \"\"\"Simple helper for colour formatting.\"\"\"\n\n    red: int\n    green: int\n    blue: int\n    brightness: int = 255\n\n    def as_hex(self) -&gt; str:\n        \"\"\"Format colour array as hex string.\"\"\"\n        return \"#\" + \"\".join(f\"{c:02x}\" for c in self)[:6]\n\n    def as_bytearray(self) -&gt; bytearray:\n        \"\"\"Convert to byte array.\"\"\"\n        return bytearray(c for c in self)\n\n    def __str__(self) -&gt; str:\n        \"\"\"For more useful cli output, format as hex.\"\"\"\n        return self.as_hex()\n</code></pre>"},{"location":"api/data/#data.Colour-attributes","title":"Attributes","text":""},{"location":"api/data/#data.Colour.blue","title":"blue  <code>instance-attribute</code>","text":"<pre><code>blue: int\n</code></pre>"},{"location":"api/data/#data.Colour.brightness","title":"brightness  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>brightness: int = 255\n</code></pre>"},{"location":"api/data/#data.Colour.green","title":"green  <code>instance-attribute</code>","text":"<pre><code>green: int\n</code></pre>"},{"location":"api/data/#data.Colour.red","title":"red  <code>instance-attribute</code>","text":"<pre><code>red: int\n</code></pre>"},{"location":"api/data/#data.Colour-functions","title":"Functions","text":""},{"location":"api/data/#data.Colour.as_bytearray","title":"as_bytearray","text":"<pre><code>as_bytearray() -&gt; bytearray\n</code></pre> <p>Convert to byte array.</p> Source code in <code>ember_mug/data.py</code> <pre><code>def as_bytearray(self) -&gt; bytearray:\n    \"\"\"Convert to byte array.\"\"\"\n    return bytearray(c for c in self)\n</code></pre>"},{"location":"api/data/#data.Colour.as_hex","title":"as_hex","text":"<pre><code>as_hex() -&gt; str\n</code></pre> <p>Format colour array as hex string.</p> Source code in <code>ember_mug/data.py</code> <pre><code>def as_hex(self) -&gt; str:\n    \"\"\"Format colour array as hex string.\"\"\"\n    return \"#\" + \"\".join(f\"{c:02x}\" for c in self)[:6]\n</code></pre>"},{"location":"api/data/#data.ModelInfo","title":"ModelInfo  <code>dataclass</code>","text":"<p>               Bases: <code>data.BaseModelInfo</code></p> <p>Model name and attributes based on mode.</p> Source code in <code>ember_mug/data.py</code> <pre><code>@dataclass\nclass ModelInfo(BaseModelInfo):\n    \"\"\"Model name and attributes based on mode.\"\"\"\n\n    @cached_property  # type: ignore[misc]\n    def name(self) -&gt; str:  # type: ignore[override]\n        \"\"\"Get a human-readable name from model number.\"\"\"\n        return DEVICE_MODEL_NAMES.get(\n            self.model or DeviceModel.UNKNOWN_DEVICE,\n            \"Unknown Device\",\n        )\n\n    @cached_property  # type: ignore[misc]\n    def capacity(self) -&gt; int | None:  # type: ignore[override]\n        \"\"\"Determine capacity in mL based on model number.\"\"\"\n        if self.model == DeviceModel.CUP_6_OZ:\n            return 178  # ml - 6oz\n        if self.model in (DeviceModel.MUG_1_10_OZ, DeviceModel.MUG_2_10_OZ):\n            return 295  # ml - 10oz\n        if self.model == DeviceModel.TRAVEL_MUG_12_OZ:\n            return 355  # ml - 12oz\n        if self.model in (DeviceModel.MUG_1_14_OZ, DeviceModel.MUG_2_14_OZ):\n            return 414  # ml - 14oz\n        if self.model == DeviceModel.TUMBLER_16_OZ:\n            return 473  # ml - 16oz\n        return None\n\n    @cached_property  # type: ignore[misc]\n    def device_type(self) -&gt; DeviceType:  # type: ignore[override]\n        \"\"\"Basic device type from model number.\"\"\"\n        if self.model == DeviceModel.TRAVEL_MUG_12_OZ:\n            return DeviceType.TRAVEL_MUG\n        if self.model == DeviceModel.TUMBLER_16_OZ:\n            return DeviceType.TUMBLER\n        if self.model == DeviceModel.CUP_6_OZ:\n            return DeviceType.CUP\n        # This could be an unknown device, but fallback to mug\n        return DeviceType.MUG\n\n    @cached_property\n    def device_attributes(self) -&gt; set[str]:\n        \"\"\"Attributes to update based on model and extra.\"\"\"\n        attributes = EXTRA_ATTRS | INITIAL_ATTRS | UPDATE_ATTRS\n        unknown = (None, DeviceModel.UNKNOWN_DEVICE)\n        if self.model in unknown or self.device_type in (DeviceType.CUP, DeviceType.TUMBLER):\n            # The Cup and Tumbler cannot be named\n            attributes -= {\"name\"}\n        elif self.model in unknown or self.device_type == DeviceType.TRAVEL_MUG:\n            # Tge Travel Mug does not have an LED colour, but has a volume attribute\n            attributes = (attributes - {\"led_colour\"}) | {\"volume_level\"}\n        if self.model != DeviceModel.TRAVEL_MUG_12_OZ:\n            # Only Travel mug has this attribute?\n            attributes -= {\"battery_voltage\"}\n        return attributes\n</code></pre>"},{"location":"api/data/#data.ModelInfo-attributes","title":"Attributes","text":""},{"location":"api/data/#data.ModelInfo.capacity","title":"capacity  <code>cached</code> <code>property</code>","text":"<pre><code>capacity: int | None\n</code></pre> <p>Determine capacity in mL based on model number.</p>"},{"location":"api/data/#data.ModelInfo.colour","title":"colour  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>colour: data.consts.DeviceColour | None = None\n</code></pre>"},{"location":"api/data/#data.ModelInfo.device_attributes","title":"device_attributes  <code>cached</code> <code>property</code>","text":"<pre><code>device_attributes: set[str]\n</code></pre> <p>Attributes to update based on model and extra.</p>"},{"location":"api/data/#data.ModelInfo.device_type","title":"device_type  <code>cached</code> <code>property</code>","text":"<pre><code>device_type: data.consts.DeviceType\n</code></pre> <p>Basic device type from model number.</p>"},{"location":"api/data/#data.ModelInfo.model","title":"model  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model: data.consts.DeviceModel | None = None\n</code></pre>"},{"location":"api/data/#data.ModelInfo.name","title":"name  <code>cached</code> <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get a human-readable name from model number.</p>"},{"location":"api/data/#data.ModelInfo-functions","title":"Functions","text":""},{"location":"api/data/#data.ModelInfo.as_dict","title":"as_dict","text":"<pre><code>as_dict() -&gt; dict[str, typing.Any]\n</code></pre> <p>Add as_dict to dataclass for serialization.</p> Source code in <code>ember_mug/data.py</code> <pre><code>def as_dict(self: DataclassInstance) -&gt; dict[str, Any]:\n    \"\"\"Add as_dict to dataclass for serialization.\"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"api/data/#data.MugData","title":"MugData  <code>dataclass</code>","text":"<p>               Bases: <code>data.AsDict</code></p> <p>Class to store/display the state of the mug.</p> Source code in <code>ember_mug/data.py</code> <pre><code>@dataclass\nclass MugData(AsDict):\n    \"\"\"Class to store/display the state of the mug.\"\"\"\n\n    # Options\n    model_info: ModelInfo\n    use_metric: bool = True\n    debug: bool = False\n\n    # Attributes\n    name: str = \"\"\n    meta: MugMeta | None = None\n    battery: BatteryInfo | None = None\n    firmware: MugFirmwareInfo | None = None\n    led_colour: Colour = field(default_factory=lambda: Colour(255, 255, 255, 255))\n    liquid_state: LiquidState | None = None\n    liquid_level: int = 0\n    temperature_unit: TemperatureUnit = TemperatureUnit.CELSIUS\n    current_temp: float = 0.0\n    target_temp: float = 0.0\n    dsk: str = \"\"\n    udsk: str | None = \"\"\n    volume_level: VolumeLevel | None = None\n    date_time_zone: datetime | None = None\n    battery_voltage: int | None = None\n\n    @property\n    def meta_display(self) -&gt; str:\n        \"\"\"Return Meta infor based on preference.\"\"\"\n        if self.meta and not self.debug:\n            return f\"Serial Number: {self.meta.serial_number}\"\n        return str(self.meta)\n\n    @property\n    def led_colour_display(self) -&gt; str:\n        \"\"\"Return colour as hex value.\"\"\"\n        return format_led_colour(self.led_colour)\n\n    @property\n    def liquid_state_display(self) -&gt; str:\n        \"\"\"Human-readable liquid state.\"\"\"\n        return self.liquid_state.label if self.liquid_state else LIQUID_STATE_UNKNOWN\n\n    @property\n    def volume_level_display(self) -&gt; str | None:\n        \"\"\"Human-readable volume level.\"\"\"\n        if self.volume_level:\n            return self.volume_level.value.capitalize()\n        return None\n\n    @property\n    def liquid_level_display(self) -&gt; str:\n        \"\"\"Human-readable liquid level.\"\"\"\n        return format_liquid_level(self.liquid_level)\n\n    @property\n    def current_temp_display(self) -&gt; str:\n        \"\"\"Human-readable current temp with unit.\"\"\"\n        return format_temp(self.current_temp, self.use_metric)\n\n    @property\n    def target_temp_display(self) -&gt; str:\n        \"\"\"Human-readable target temp with unit.\"\"\"\n        return format_temp(self.target_temp, self.use_metric)\n\n    def update_info(self, **kwargs: Any) -&gt; list[Change]:\n        \"\"\"Update attributes of the mug if they haven't changed.\"\"\"\n        changes: list[Change] = []\n        for attr, new_value in kwargs.items():\n            if (old_value := getattr(self, attr)) != new_value:\n                setattr(self, attr, new_value)\n                changes.append(Change(attr, old_value, new_value))\n        return changes\n\n    def get_formatted_attr(self, attr: str) -&gt; str | None:\n        \"\"\"Get the display value of a given attribute.\"\"\"\n        if display_value := getattr(self, f\"{attr}_display\", None):\n            return display_value\n        return getattr(self, attr)\n\n    @property\n    def formatted(self) -&gt; dict[str, Any]:\n        \"\"\"Return human-readable names and values for all attributes for display.\"\"\"\n        all_attrs = self.model_info.device_attributes | {\"use_metric\"}\n        if not self.debug:\n            all_attrs -= EXTRA_ATTRS\n        return {label: self.get_formatted_attr(attr) for attr, label in ATTR_LABELS.items() if attr in all_attrs}\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Dump all attributes as dict for info/debugging.\"\"\"\n        data = asdict(self)\n        all_attrs = self.model_info.device_attributes\n        if not self.debug:\n            all_attrs -= EXTRA_ATTRS\n        data.update(\n            {\n                f\"{attr}_display\": getattr(self, f\"{attr}_display\", None)\n                for attr in all_attrs\n                if hasattr(self, f\"{attr}_display\")\n            },\n        )\n        return data\n</code></pre>"},{"location":"api/data/#data.MugData-attributes","title":"Attributes","text":""},{"location":"api/data/#data.MugData.battery","title":"battery  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>battery: data.BatteryInfo | None = None\n</code></pre>"},{"location":"api/data/#data.MugData.battery_voltage","title":"battery_voltage  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>battery_voltage: int | None = None\n</code></pre>"},{"location":"api/data/#data.MugData.current_temp","title":"current_temp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>current_temp: float = 0.0\n</code></pre>"},{"location":"api/data/#data.MugData.current_temp_display","title":"current_temp_display  <code>property</code>","text":"<pre><code>current_temp_display: str\n</code></pre> <p>Human-readable current temp with unit.</p>"},{"location":"api/data/#data.MugData.date_time_zone","title":"date_time_zone  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>date_time_zone: datetime.datetime | None = None\n</code></pre>"},{"location":"api/data/#data.MugData.debug","title":"debug  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug: bool = False\n</code></pre>"},{"location":"api/data/#data.MugData.dsk","title":"dsk  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dsk: str = ''\n</code></pre>"},{"location":"api/data/#data.MugData.firmware","title":"firmware  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>firmware: data.MugFirmwareInfo | None = None\n</code></pre>"},{"location":"api/data/#data.MugData.formatted","title":"formatted  <code>property</code>","text":"<pre><code>formatted: dict[str, typing.Any]\n</code></pre> <p>Return human-readable names and values for all attributes for display.</p>"},{"location":"api/data/#data.MugData.led_colour","title":"led_colour  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>led_colour: data.Colour = dataclasses.field(\n    default_factory=lambda: data.Colour(255, 255, 255, 255)\n)\n</code></pre>"},{"location":"api/data/#data.MugData.led_colour_display","title":"led_colour_display  <code>property</code>","text":"<pre><code>led_colour_display: str\n</code></pre> <p>Return colour as hex value.</p>"},{"location":"api/data/#data.MugData.liquid_level","title":"liquid_level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>liquid_level: int = 0\n</code></pre>"},{"location":"api/data/#data.MugData.liquid_level_display","title":"liquid_level_display  <code>property</code>","text":"<pre><code>liquid_level_display: str\n</code></pre> <p>Human-readable liquid level.</p>"},{"location":"api/data/#data.MugData.liquid_state","title":"liquid_state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>liquid_state: data.consts.LiquidState | None = None\n</code></pre>"},{"location":"api/data/#data.MugData.liquid_state_display","title":"liquid_state_display  <code>property</code>","text":"<pre><code>liquid_state_display: str\n</code></pre> <p>Human-readable liquid state.</p>"},{"location":"api/data/#data.MugData.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: data.MugMeta | None = None\n</code></pre>"},{"location":"api/data/#data.MugData.meta_display","title":"meta_display  <code>property</code>","text":"<pre><code>meta_display: str\n</code></pre> <p>Return Meta infor based on preference.</p>"},{"location":"api/data/#data.MugData.model_info","title":"model_info  <code>instance-attribute</code>","text":"<pre><code>model_info: data.ModelInfo\n</code></pre>"},{"location":"api/data/#data.MugData.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = ''\n</code></pre>"},{"location":"api/data/#data.MugData.target_temp","title":"target_temp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>target_temp: float = 0.0\n</code></pre>"},{"location":"api/data/#data.MugData.target_temp_display","title":"target_temp_display  <code>property</code>","text":"<pre><code>target_temp_display: str\n</code></pre> <p>Human-readable target temp with unit.</p>"},{"location":"api/data/#data.MugData.temperature_unit","title":"temperature_unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>temperature_unit: data.consts.TemperatureUnit = (\n    data.consts.TemperatureUnit.CELSIUS\n)\n</code></pre>"},{"location":"api/data/#data.MugData.udsk","title":"udsk  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>udsk: str | None = ''\n</code></pre>"},{"location":"api/data/#data.MugData.use_metric","title":"use_metric  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>use_metric: bool = True\n</code></pre>"},{"location":"api/data/#data.MugData.volume_level","title":"volume_level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>volume_level: data.consts.VolumeLevel | None = None\n</code></pre>"},{"location":"api/data/#data.MugData.volume_level_display","title":"volume_level_display  <code>property</code>","text":"<pre><code>volume_level_display: str | None\n</code></pre> <p>Human-readable volume level.</p>"},{"location":"api/data/#data.MugData-functions","title":"Functions","text":""},{"location":"api/data/#data.MugData.as_dict","title":"as_dict","text":"<pre><code>as_dict() -&gt; dict[str, typing.Any]\n</code></pre> <p>Dump all attributes as dict for info/debugging.</p> Source code in <code>ember_mug/data.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Dump all attributes as dict for info/debugging.\"\"\"\n    data = asdict(self)\n    all_attrs = self.model_info.device_attributes\n    if not self.debug:\n        all_attrs -= EXTRA_ATTRS\n    data.update(\n        {\n            f\"{attr}_display\": getattr(self, f\"{attr}_display\", None)\n            for attr in all_attrs\n            if hasattr(self, f\"{attr}_display\")\n        },\n    )\n    return data\n</code></pre>"},{"location":"api/data/#data.MugData.get_formatted_attr","title":"get_formatted_attr","text":"<pre><code>get_formatted_attr(attr: str) -&gt; str | None\n</code></pre> <p>Get the display value of a given attribute.</p> Source code in <code>ember_mug/data.py</code> <pre><code>def get_formatted_attr(self, attr: str) -&gt; str | None:\n    \"\"\"Get the display value of a given attribute.\"\"\"\n    if display_value := getattr(self, f\"{attr}_display\", None):\n        return display_value\n    return getattr(self, attr)\n</code></pre>"},{"location":"api/data/#data.MugData.update_info","title":"update_info","text":"<pre><code>update_info(**kwargs: typing.Any) -&gt; list[data.Change]\n</code></pre> <p>Update attributes of the mug if they haven't changed.</p> Source code in <code>ember_mug/data.py</code> <pre><code>def update_info(self, **kwargs: Any) -&gt; list[Change]:\n    \"\"\"Update attributes of the mug if they haven't changed.\"\"\"\n    changes: list[Change] = []\n    for attr, new_value in kwargs.items():\n        if (old_value := getattr(self, attr)) != new_value:\n            setattr(self, attr, new_value)\n            changes.append(Change(attr, old_value, new_value))\n    return changes\n</code></pre>"},{"location":"api/data/#data.MugFirmwareInfo","title":"MugFirmwareInfo  <code>dataclass</code>","text":"<p>               Bases: <code>data.AsDict</code></p> <p>Firmware versions.</p> Source code in <code>ember_mug/data.py</code> <pre><code>@dataclass\nclass MugFirmwareInfo(AsDict):\n    \"\"\"Firmware versions.\"\"\"\n\n    version: int\n    hardware: int\n    bootloader: int\n\n    @classmethod\n    def from_bytes(cls, data: bytes) -&gt; MugFirmwareInfo:\n        \"\"\"Initialize from raw bytes.\"\"\"\n        return cls(\n            version=bytes_to_little_int(data[:2]),\n            hardware=bytes_to_little_int(data[2:4]),\n            bootloader=bytes_to_little_int(data[4:]),\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Format nicely for printing.\"\"\"\n        return \", \".join(\n            (\n                f\"Version: {self.version}\",\n                f\"Hardware: {self.hardware}\",\n                f\"Bootloader: {self.bootloader}\",\n            ),\n        )\n</code></pre>"},{"location":"api/data/#data.MugFirmwareInfo-attributes","title":"Attributes","text":""},{"location":"api/data/#data.MugFirmwareInfo.bootloader","title":"bootloader  <code>instance-attribute</code>","text":"<pre><code>bootloader: int\n</code></pre>"},{"location":"api/data/#data.MugFirmwareInfo.hardware","title":"hardware  <code>instance-attribute</code>","text":"<pre><code>hardware: int\n</code></pre>"},{"location":"api/data/#data.MugFirmwareInfo.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: int\n</code></pre>"},{"location":"api/data/#data.MugFirmwareInfo-functions","title":"Functions","text":""},{"location":"api/data/#data.MugFirmwareInfo.as_dict","title":"as_dict","text":"<pre><code>as_dict() -&gt; dict[str, typing.Any]\n</code></pre> <p>Add as_dict to dataclass for serialization.</p> Source code in <code>ember_mug/data.py</code> <pre><code>def as_dict(self: DataclassInstance) -&gt; dict[str, Any]:\n    \"\"\"Add as_dict to dataclass for serialization.\"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"api/data/#data.MugFirmwareInfo.from_bytes","title":"from_bytes  <code>classmethod</code>","text":"<pre><code>from_bytes(data: bytes) -&gt; data.MugFirmwareInfo\n</code></pre> <p>Initialize from raw bytes.</p> Source code in <code>ember_mug/data.py</code> <pre><code>@classmethod\ndef from_bytes(cls, data: bytes) -&gt; MugFirmwareInfo:\n    \"\"\"Initialize from raw bytes.\"\"\"\n    return cls(\n        version=bytes_to_little_int(data[:2]),\n        hardware=bytes_to_little_int(data[2:4]),\n        bootloader=bytes_to_little_int(data[4:]),\n    )\n</code></pre>"},{"location":"api/data/#data.MugMeta","title":"MugMeta  <code>dataclass</code>","text":"<p>               Bases: <code>data.AsDict</code></p> <p>Meta data for mug.</p> Source code in <code>ember_mug/data.py</code> <pre><code>@dataclass\nclass MugMeta(AsDict):\n    \"\"\"Meta data for mug.\"\"\"\n\n    mug_id: str  # unsure if this value is properly decoded\n    serial_number: str\n\n    @classmethod\n    def from_bytes(cls, data: bytes) -&gt; MugMeta:\n        \"\"\"Initialize from raw bytes.\"\"\"\n        return cls(\n            mug_id=decode_byte_string(data[:6]),\n            serial_number=data[7:].decode(),\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Format nicely for printing.\"\"\"\n        return f\"Mug ID: {self.mug_id}, Serial Number: {self.serial_number}\"\n</code></pre>"},{"location":"api/data/#data.MugMeta-attributes","title":"Attributes","text":""},{"location":"api/data/#data.MugMeta.mug_id","title":"mug_id  <code>instance-attribute</code>","text":"<pre><code>mug_id: str\n</code></pre>"},{"location":"api/data/#data.MugMeta.serial_number","title":"serial_number  <code>instance-attribute</code>","text":"<pre><code>serial_number: str\n</code></pre>"},{"location":"api/data/#data.MugMeta-functions","title":"Functions","text":""},{"location":"api/data/#data.MugMeta.as_dict","title":"as_dict","text":"<pre><code>as_dict() -&gt; dict[str, typing.Any]\n</code></pre> <p>Add as_dict to dataclass for serialization.</p> Source code in <code>ember_mug/data.py</code> <pre><code>def as_dict(self: DataclassInstance) -&gt; dict[str, Any]:\n    \"\"\"Add as_dict to dataclass for serialization.\"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"api/data/#data.MugMeta.from_bytes","title":"from_bytes  <code>classmethod</code>","text":"<pre><code>from_bytes(data: bytes) -&gt; data.MugMeta\n</code></pre> <p>Initialize from raw bytes.</p> Source code in <code>ember_mug/data.py</code> <pre><code>@classmethod\ndef from_bytes(cls, data: bytes) -&gt; MugMeta:\n    \"\"\"Initialize from raw bytes.\"\"\"\n    return cls(\n        mug_id=decode_byte_string(data[:6]),\n        serial_number=data[7:].decode(),\n    )\n</code></pre>"},{"location":"api/formatting/","title":"formatting","text":""},{"location":"api/formatting/#formatting","title":"formatting","text":"<p>Helpers for formatting values for display.</p>"},{"location":"api/formatting/#formatting-functions","title":"Functions","text":""},{"location":"api/formatting/#formatting.format_capacity","title":"format_capacity","text":"<pre><code>format_capacity(\n    capacity: int | None, metric: bool = True\n) -&gt; str\n</code></pre> <p>Format capacity for display.</p> Source code in <code>ember_mug/formatting.py</code> <pre><code>def format_capacity(capacity: int | None, metric: bool = True) -&gt; str:\n    \"\"\"Format capacity for display.\"\"\"\n    if capacity is None:\n        return \"Unknown\"\n    if metric is False:\n        # Convert to fahrenheit\n        capacity = round(capacity * 0.033814)\n        return f\"{capacity}oz\"\n    return f\"{capacity}ml\"\n</code></pre>"},{"location":"api/formatting/#formatting.format_led_colour","title":"format_led_colour","text":"<pre><code>format_led_colour(\n    led_colour: formatting.data.Colour,\n) -&gt; str\n</code></pre> <p>Return colour as hex value.</p> Source code in <code>ember_mug/formatting.py</code> <pre><code>def format_led_colour(led_colour: Colour) -&gt; str:\n    \"\"\"Return colour as hex value.\"\"\"\n    return led_colour.as_hex()\n</code></pre>"},{"location":"api/formatting/#formatting.format_liquid_level","title":"format_liquid_level","text":"<pre><code>format_liquid_level(liquid_level: int) -&gt; str\n</code></pre> <p>Human readable liquid level.</p> Source code in <code>ember_mug/formatting.py</code> <pre><code>def format_liquid_level(liquid_level: int) -&gt; str:\n    \"\"\"Human readable liquid level.\"\"\"\n    return f\"{(liquid_level / 30 * 100):.2f}%\"\n</code></pre>"},{"location":"api/formatting/#formatting.format_temp","title":"format_temp","text":"<pre><code>format_temp(temp: float, metric: bool = True) -&gt; str\n</code></pre> <p>Format temperature with the correct unit.</p> Source code in <code>ember_mug/formatting.py</code> <pre><code>def format_temp(temp: float, metric: bool = True) -&gt; str:\n    \"\"\"Format temperature with the correct unit.\"\"\"\n    unit = \"C\" if metric else \"F\"\n    return f\"{temp:.2f}\u00b0{unit}\"\n</code></pre>"},{"location":"api/mug/","title":"mug","text":""},{"location":"api/mug/#mug","title":"mug","text":"<p>Objects and methods related to connection to the mug.</p>"},{"location":"api/mug/#mug-attributes","title":"Attributes","text":""},{"location":"api/mug/#mug.DISCONNECT_DELAY","title":"DISCONNECT_DELAY  <code>module-attribute</code>","text":"<pre><code>DISCONNECT_DELAY = 120\n</code></pre>"},{"location":"api/mug/#mug.P","title":"P  <code>module-attribute</code>","text":"<pre><code>P = typing.ParamSpec('P')\n</code></pre>"},{"location":"api/mug/#mug.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = typing.TypeVar('T')\n</code></pre>"},{"location":"api/mug/#mug.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = logging.getLogger(__name__)\n</code></pre>"},{"location":"api/mug/#mug-classes","title":"Classes","text":""},{"location":"api/mug/#mug.EmberMug","title":"EmberMug","text":"<p>Handle actual the actual mug connection and update states.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>class EmberMug:\n    \"\"\"Handle actual the actual mug connection and update states.\"\"\"\n\n    def __init__(\n        self,\n        ble_device: BLEDevice,\n        model_info: ModelInfo,\n        use_metric: bool = True,\n        debug: bool = False,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initialize connection manager.\"\"\"\n        self.device = ble_device\n        self.data = MugData(model_info, use_metric=use_metric, debug=debug)\n\n        self.debug = debug\n        self._connect_lock = asyncio.Lock()\n        self._operation_lock = asyncio.Lock()\n        self._expected_disconnect = False\n        self._callbacks: dict[Callable[[MugData], None], Callable[[], None]] = {}\n        self._client: BleakClient = None  # type: ignore[assignment]\n        self._queued_updates: set[str] = set()\n        self._latest_events: dict[int, float] = {}\n        self._client_kwargs: dict[str, str] = {}\n\n        logger.debug(\"New mug connection initialized.\")\n        self.set_client_options(**kwargs)\n\n    def ble_event_callback(self, ble_device: BLEDevice, advertisement_data: AdvertisementData) -&gt; None:\n        \"\"\"Update BLE Device and, if needed, model information.\"\"\"\n        self.device = ble_device\n        logger.debug(\"Set new device from %s to %s\", self.device, ble_device)\n        if (\n            not self.data.model_info.model\n            and advertisement_data.manufacturer_data\n            and (model_info := get_model_info_from_advertiser_data(advertisement_data))\n        ):\n            logger.debug(\n                \"Updated model info from advertisement data (%s) -&gt; %s\",\n                advertisement_data,\n                model_info,\n            )\n            self.data.model_info = model_info\n\n    @cached_property\n    def model_name(self) -&gt; str | None:\n        \"\"\"Shortcut to model name.\"\"\"\n        return self.data.model_info.model.value if self.data.model_info.model else None\n\n    @property\n    def can_write(self) -&gt; bool:\n        \"\"\"Check if the mug can support write operations.\"\"\"\n        return self.data.udsk is not None\n\n    def has_attribute(self, attribute: str) -&gt; bool:\n        \"\"\"Check whether the device has the given attribute.\"\"\"\n        return attribute in self.data.model_info.device_attributes\n\n    async def _ensure_connection(self) -&gt; None:\n        \"\"\"Connect to mug.\"\"\"\n        if self._connect_lock.locked():\n            logger.debug(\"Connection to %s already in progress. Waiting first.\", self.device.name)\n\n        if self._client is not None and self._client.is_connected:\n            return\n\n        async with self._connect_lock:\n            # Also check after lock is acquired\n            if self._client is not None and self._client.is_connected:\n                return\n            try:\n                logger.debug(\"Establishing a new connection from mug (ID: %s) to %s\", id(self), self.device)\n                client = await establish_connection(\n                    client_class=BleakClient,\n                    device=self.device,\n                    name=f\"{self.data.name} ({self.device.address})\",\n                    disconnected_callback=self._disconnect_callback,\n                    ble_device_callback=lambda: self.device,\n                )\n                if self.debug is True:\n                    await discover_services(client)\n                self._expected_disconnect = False\n            except (TimeoutError, BleakError) as error:\n                logger.debug(\"%s: Failed to connect to the mug: %s\", self.device, error)\n                raise error\n            # Attempt to pair for good measure\n            try:\n                await client.pair()\n            except (BleakError, EOFError):\n                pass\n            except NotImplementedError:\n                # workaround for Home Assistant ESPHome Proxy backend which does not allow pairing.\n                logger.warning(\n                    \"Pairing not implemented. \"\n                    \"If your mug is still in pairing mode (blinking blue) tap the button on the bottom to exit.\",\n                )\n            self._client = client\n            await self.subscribe()\n\n    async def _read(self, characteristic: MugCharacteristic) -&gt; bytearray:\n        \"\"\"Help read characteristic from Mug.\"\"\"\n        self._check_operation_lock()\n        async with self._operation_lock:\n            data = await self._client.read_gatt_char(characteristic.uuid)\n            logger.debug(\"Read attribute '%s' with value '%s'\", characteristic, data)\n            return data\n\n    async def _write(self, characteristic: MugCharacteristic, data: bytearray) -&gt; None:\n        \"\"\"Help write characteristic to Mug.\"\"\"\n        self._check_operation_lock()\n        async with self._operation_lock:\n            await self._ensure_connection()\n            try:\n                await self._client.write_gatt_char(characteristic.uuid, data)\n                logger.debug(\"Wrote '%s' to attribute '%s'\", data, characteristic)\n            except BleakError as e:\n                logger.error(\"Failed to write '%s' to attribute '%s': %s\", data, characteristic, e)\n                raise\n\n    async def disconnect(self, expected: bool = True) -&gt; None:\n        \"\"\"Disconnect from mug and stop listening to notifications.\"\"\"\n        logger.debug(\"%s disconnect called\", \"Expected\" if expected else \"Unexpected\")\n        self._expected_disconnect = expected\n        if self._client and self._client.is_connected:\n            async with self._connect_lock:\n                await self.unsubscribe()\n                await self._client.disconnect()\n        self._client = None  # type: ignore[assignment]\n        self._expected_disconnect = False\n\n    def _disconnect_callback(self, client: BleakClient) -&gt; None:\n        \"\"\"Disconnect from device.\"\"\"\n        if self._expected_disconnect:\n            logger.debug(\"Disconnect callback called\")\n        else:\n            logger.debug(\"Unexpectedly disconnected\")\n\n    def _fire_callbacks(self) -&gt; None:\n        \"\"\"Fire the callbacks.\"\"\"\n        logger.debug(\"Firing callbacks: %s\", self._callbacks)\n        for callback in self._callbacks:\n            callback(self.data)\n\n    def _check_operation_lock(self) -&gt; None:\n        \"\"\"Check and print message if lock occupied.\"\"\"\n        if self._operation_lock.locked():\n            logger.debug(\"Operation already in progress. waiting for it to complete\")\n\n    def register_callback(self, callback: Callable[[MugData], None]) -&gt; Callable[[], None]:\n        \"\"\"Register a callback to be called when the state changes.\"\"\"\n        if existing_unregister_callback := self._callbacks.get(callback):\n            logger.debug(\"Callback %s already registered\", callback)\n            return existing_unregister_callback\n\n        def unregister_callback() -&gt; None:\n            if callback in self._callbacks:\n                del self._callbacks[callback]\n            logger.debug(\"Unregistered callback: %s\", callback)\n\n        self._callbacks[callback] = unregister_callback\n        logger.debug(\"Registered callback: %s\", callback)\n        return unregister_callback\n\n    async def discover_services(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Discover services for development or debugging.\n\n        Call discover_services with this client, ensuring the connection is active first.\n        \"\"\"\n        self._check_operation_lock()\n        async with self._operation_lock:\n            await self._ensure_connection()\n            return await discover_services(self._client)\n\n    async def get_meta(self) -&gt; MugMeta:\n        \"\"\"Fetch Meta info from the mug (Serial number and ID).\"\"\"\n        return MugMeta.from_bytes(await self._read(MugCharacteristic.MUG_ID))\n\n    async def get_battery(self) -&gt; BatteryInfo:\n        \"\"\"Get Battery percent from mug gatt.\"\"\"\n        return BatteryInfo.from_bytes(await self._read(MugCharacteristic.BATTERY))\n\n    @require_attribute(\"led_colour\")\n    async def get_led_colour(self) -&gt; Colour:\n        \"\"\"Get RGBA colours from mug gatt.\"\"\"\n        colour_data = await self._read(MugCharacteristic.LED)\n        return Colour(*bytearray(colour_data))\n\n    @require_attribute(\"led_colour\")\n    async def set_led_colour(self, colour: Colour) -&gt; None:\n        \"\"\"Set new target temp for mug.\"\"\"\n        await self._write(MugCharacteristic.LED, colour.as_bytearray())\n        self.data.led_colour = colour\n\n    async def get_target_temp(self) -&gt; float:\n        \"\"\"Get target temp form mug gatt.\"\"\"\n        temp_bytes = await self._read(MugCharacteristic.TARGET_TEMPERATURE)\n        return temp_from_bytes(temp_bytes, self.data.use_metric)\n\n    async def set_target_temp(self, target_temp: float) -&gt; None:\n        \"\"\"Set new target temp for mug.\"\"\"\n        unit = TemperatureUnit.CELSIUS if self.data.use_metric else TemperatureUnit.FAHRENHEIT\n        min_temp, max_temp = MIN_MAX_TEMPS[unit]\n        if target_temp != 0 and not (min_temp &lt;= target_temp &lt;= max_temp):\n            raise ValueError(f\"Temperature should be between {min_temp} and {max_temp} or 0.\")\n\n        if self.data.use_metric is False:\n            target_temp = convert_temp_to_celsius(target_temp)\n\n        target = bytearray(int(target_temp / 0.01).to_bytes(2, \"little\"))\n        await self._write(MugCharacteristic.TARGET_TEMPERATURE, target)\n        self.data.target_temp = target_temp\n\n    async def get_current_temp(self) -&gt; float:\n        \"\"\"Get current temp from mug gatt.\"\"\"\n        temp_bytes = await self._read(MugCharacteristic.CURRENT_TEMPERATURE)\n        return temp_from_bytes(temp_bytes, self.data.use_metric)\n\n    async def get_liquid_level(self) -&gt; int:\n        \"\"\"Get liquid level from mug gatt.\"\"\"\n        liquid_level_bytes = await self._read(MugCharacteristic.LIQUID_LEVEL)\n        return bytes_to_little_int(liquid_level_bytes)\n\n    @require_attribute(\"volume_level\")\n    async def get_volume_level(self) -&gt; VolumeLevel | None:\n        \"\"\"Get volume level from mug gatt.\"\"\"\n        volume_bytes = await self._read(MugCharacteristic.VOLUME)\n        volume_int = bytes_to_little_int(volume_bytes)\n        return VolumeLevel.from_state(volume_int)\n\n    @require_attribute(\"volume_level\")\n    async def set_volume_level(self, volume: int | VolumeLevel) -&gt; None:\n        \"\"\"Set volume_level on Travel Mug.\"\"\"\n        if not isinstance(volume, VolumeLevel) and isinstance(volume, int) and volume not in (0, 1, 2):\n            msg = \"Volume level value should be 0, 1, 2 or a VolumeLevel enum\"\n            raise ValueError(msg)\n        volume_level = volume if isinstance(volume, VolumeLevel) else VolumeLevel.from_state(volume)\n        await self._write(MugCharacteristic.VOLUME, bytearray([volume_level.state]))\n        self.data.volume_level = volume_level\n\n    async def get_liquid_state(self) -&gt; LiquidState:\n        \"\"\"Get liquid state from mug gatt.\"\"\"\n        liquid_state_bytes = await self._read(MugCharacteristic.LIQUID_STATE)\n        state = bytes_to_little_int(liquid_state_bytes)\n        return LiquidState(state)\n\n    @require_attribute(\"name\")\n    async def get_name(self) -&gt; str:\n        \"\"\"Get mug name from gatt.\"\"\"\n        name_bytes: bytearray = await self._read(MugCharacteristic.MUG_NAME)\n        return bytes(name_bytes).decode(\"utf8\")\n\n    @require_attribute(\"name\")\n    async def set_name(self, name: str) -&gt; None:\n        \"\"\"Assign new name to mug.\"\"\"\n        if MUG_NAME_REGEX.match(name) is None:\n            msg = \"Name cannot contain any special characters and must be 16 characters or less\"\n            raise ValueError(msg)\n        await self._write(MugCharacteristic.MUG_NAME, bytearray(name.encode(\"utf8\")))\n        self.data.name = name\n\n    async def get_udsk(self) -&gt; str | None:\n        \"\"\"Get mug udsk from gatt.\"\"\"\n        try:\n            data = await self._read(MugCharacteristic.UDSK)\n            if data == bytearray([0] * 20):\n                return None\n            return decode_byte_string(data)\n        except (BleakError, ValueError) as e:\n            logger.debug(\"Unable to read UDSK: %s\", e)\n        return None\n\n    async def set_udsk(self, udsk: str) -&gt; None:\n        \"\"\"Attempt to write udsk.\"\"\"\n        await self._write(MugCharacteristic.UDSK, bytearray(encode_byte_string(udsk)))\n        self.data.udsk = udsk\n\n    async def get_dsk(self) -&gt; str:\n        \"\"\"Get mug dsk from gatt.\"\"\"\n        try:\n            return decode_byte_string(await self._read(MugCharacteristic.DSK))\n        except BleakError as e:\n            logger.debug(\"Unable to read DSK: %s\", e)\n        return \"\"\n\n    async def get_temperature_unit(self) -&gt; TemperatureUnit:\n        \"\"\"Get mug temp unit.\"\"\"\n        unit_bytes = await self._read(MugCharacteristic.TEMPERATURE_UNIT)\n        if bytes_to_little_int(unit_bytes) == 0:\n            return TemperatureUnit.CELSIUS\n        return TemperatureUnit.FAHRENHEIT\n\n    async def set_temperature_unit(self, unit: Literal[\"\u00b0C\", \"\u00b0F\"] | TemperatureUnit | Enum) -&gt; None:\n        \"\"\"Set mug unit.\"\"\"\n        text_unit = unit.value if isinstance(unit, Enum) else unit\n        unit_bytes = bytearray([1 if text_unit == TemperatureUnit.FAHRENHEIT else 0])\n        await self._write(MugCharacteristic.TEMPERATURE_UNIT, unit_bytes)\n        self.data.temperature_unit = TemperatureUnit(unit)\n\n    async def ensure_correct_unit(self) -&gt; None:\n        \"\"\"Set mug unit if it's not what we want.\"\"\"\n        desired = TemperatureUnit.CELSIUS if self.data.use_metric else TemperatureUnit.FAHRENHEIT\n        if self.data.temperature_unit != desired:\n            await self.set_temperature_unit(desired)\n\n    async def get_battery_voltage(self) -&gt; int:\n        \"\"\"Get voltage and charge time.\"\"\"\n        battery_voltage_bytes = await self._read(MugCharacteristic.CONTROL_REGISTER_DATA)\n        return bytes_to_big_int(battery_voltage_bytes[:1])\n\n    async def get_date_time_zone(self) -&gt; datetime | None:\n        \"\"\"Get date and time zone.\"\"\"\n        date_time_zone_bytes = await self._read(MugCharacteristic.DATE_TIME_AND_ZONE)\n        time_value = bytes_to_big_int(date_time_zone_bytes[:4])\n        return datetime.fromtimestamp(time_value, UTC) if time_value &gt; 0 else None\n\n    async def get_firmware(self) -&gt; MugFirmwareInfo:\n        \"\"\"Get firmware info.\"\"\"\n        return MugFirmwareInfo.from_bytes(await self._read(MugCharacteristic.FIRMWARE))\n\n    async def update_initial(self) -&gt; list[Change]:\n        \"\"\"Update attributes that don't normally change and don't need to be regularly updated.\"\"\"\n        return await self._update_multiple(INITIAL_ATTRS)\n\n    async def update_all(self) -&gt; list[Change]:\n        \"\"\"Update all standard attributes.\"\"\"\n        return await self._update_multiple(\n            self.data.model_info.device_attributes - INITIAL_ATTRS,\n        )\n\n    async def _update_multiple(self, attrs: set[str]) -&gt; list[Change]:\n        \"\"\"Update a list of attributes from the mug.\"\"\"\n        logger.debug(\"Updating the following attributes: %s\", attrs)\n        await self._ensure_connection()\n        changes = self.data.update_info(**{attr: await getattr(self, f\"get_{attr}\")() for attr in attrs})\n        if changes:\n            self._fire_callbacks()\n        logger.debug(\"Attributes updated: %s\", changes)\n        return changes\n\n    async def update_queued_attributes(self) -&gt; list[Change]:\n        \"\"\"Update all attributes in queue.\"\"\"\n        logger.debug(\"Updating queued attributes: %s\", self._queued_updates)\n        if not self._queued_updates:\n            return []\n        queued_updates = set(self._queued_updates)\n        self._queued_updates.clear()\n        await self._ensure_connection()\n        changes = self.data.update_info(**{attr: await getattr(self, f\"get_{attr}\")() for attr in queued_updates})\n        if changes:\n            self._fire_callbacks()\n        return changes\n\n    def _notify_callback(self, characteristic: BleakGATTCharacteristic, data: bytearray) -&gt; None:\n        \"\"\"Push events from the mug to indicate changes.\"\"\"\n        event_id = data[0]\n        now = time()\n        if (last_time := self._latest_events.get(event_id)) and now - last_time &lt; 5:\n            return\n        self._latest_events[event_id] = now\n\n        if characteristic.uuid == MugCharacteristic.STATISTICS.uuid:\n            logger.info(\"Statistics received from %s (%s) - Data: %s.\", self.model_name, event_id, data)\n            return\n\n        logger.debug(\"Push event received from %s (%s) - Data: %s.\", self.model_name, event_id, data)\n\n        # Check known IDs\n        if event_id in PUSH_EVENT_BATTERY_IDS:\n            # 1, 2 and 3 : Battery Change\n            if event_id in (\n                PushEvent.CHARGER_CONNECTED,\n                PushEvent.CHARGER_DISCONNECTED,\n            ):\n                self.data.battery = BatteryInfo(\n                    percent=self.data.battery.percent if self.data.battery else 0,\n                    on_charging_base=event_id == PushEvent.CHARGER_CONNECTED,\n                )\n                self._fire_callbacks()\n            # All indicate changes in battery\n            self._queued_updates.add(\"battery\")\n        elif event_id == PushEvent.TARGET_TEMPERATURE_CHANGED:\n            self._queued_updates.add(\"target_temp\")\n        elif event_id == PushEvent.DRINK_TEMPERATURE_CHANGED:\n            self._queued_updates.add(\"current_temp\")\n        elif event_id == PushEvent.AUTH_INFO_NOT_FOUND:\n            logger.warning(\"Auth info missing\")\n        elif event_id == PushEvent.LIQUID_LEVEL_CHANGED:\n            self._queued_updates.add(\"liquid_level\")\n        elif event_id == PushEvent.LIQUID_STATE_CHANGED:\n            self._queued_updates.add(\"liquid_state\")\n        elif event_id == PushEvent.BATTERY_VOLTAGE_STATE_CHANGED:\n            self._queued_updates.add(\"battery_voltage\")\n        else:\n            logger.debug(\"Unknown event received %s\", event_id)\n\n    async def unsubscribe(self) -&gt; None:\n        \"\"\"Unsubscribe from Mug notifications.\"\"\"\n        logger.debug(\"Unsubscribe called\")\n        if not self._client:\n            return\n        with contextlib.suppress(BleakError):\n            await self._client.stop_notify(MugCharacteristic.PUSH_EVENT.uuid)\n            if self.debug:\n                await self._client.stop_notify(MugCharacteristic.STATISTICS.uuid)\n\n    async def subscribe(self) -&gt; None:\n        \"\"\"Subscribe to notifications from the mug.\"\"\"\n        try:\n            logger.info(\"Subscribe to Push Events\")\n            await self._client.start_notify(MugCharacteristic.PUSH_EVENT.uuid, self._notify_callback)\n            if self.debug:\n                await self._client.start_notify(MugCharacteristic.STATISTICS.uuid, self._notify_callback)\n        except Exception as e:\n            logger.warning(\"Failed to subscribe to state attr: %s\", e)\n\n    def set_client_options(self, **kwargs: str) -&gt; None:\n        \"\"\"Update options in case they need to overriden in some cases.\"\"\"\n        if kwargs.get(\"adapter\") and IS_LINUX is False:\n            msg = \"The adapter option is only valid for the Linux BlueZ Backend.\"\n            raise ValueError(msg)\n        self._client_kwargs = {**kwargs}\n\n    @contextlib.asynccontextmanager\n    async def connection(self, **kwargs: str) -&gt; AsyncIterator[EmberMug]:\n        \"\"\"Establish a connection and close automatically.\"\"\"\n        self.set_client_options(**kwargs)\n        # This will happen automatically, but calling it now will give us immediate feedback\n        await self._ensure_connection()\n        yield self\n        await self.disconnect()\n</code></pre>"},{"location":"api/mug/#mug.EmberMug-attributes","title":"Attributes","text":""},{"location":"api/mug/#mug.EmberMug.can_write","title":"can_write  <code>property</code>","text":"<pre><code>can_write: bool\n</code></pre> <p>Check if the mug can support write operations.</p>"},{"location":"api/mug/#mug.EmberMug.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data = mug.data.MugData(\n    mug.EmberMug(model_info),\n    use_metric=mug.EmberMug(use_metric),\n    debug=mug.EmberMug(debug),\n)\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.debug","title":"debug  <code>instance-attribute</code>","text":"<pre><code>debug = mug.EmberMug(debug)\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.device","title":"device  <code>instance-attribute</code>","text":"<pre><code>device = mug.EmberMug(ble_device)\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.model_name","title":"model_name  <code>cached</code> <code>property</code>","text":"<pre><code>model_name: str | None\n</code></pre> <p>Shortcut to model name.</p>"},{"location":"api/mug/#mug.EmberMug-functions","title":"Functions","text":""},{"location":"api/mug/#mug.EmberMug.ble_event_callback","title":"ble_event_callback","text":"<pre><code>ble_event_callback(\n    ble_device: bleak.backends.device.BLEDevice,\n    advertisement_data: bleak.AdvertisementData,\n) -&gt; None\n</code></pre> <p>Update BLE Device and, if needed, model information.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>def ble_event_callback(self, ble_device: BLEDevice, advertisement_data: AdvertisementData) -&gt; None:\n    \"\"\"Update BLE Device and, if needed, model information.\"\"\"\n    self.device = ble_device\n    logger.debug(\"Set new device from %s to %s\", self.device, ble_device)\n    if (\n        not self.data.model_info.model\n        and advertisement_data.manufacturer_data\n        and (model_info := get_model_info_from_advertiser_data(advertisement_data))\n    ):\n        logger.debug(\n            \"Updated model info from advertisement data (%s) -&gt; %s\",\n            advertisement_data,\n            model_info,\n        )\n        self.data.model_info = model_info\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.connection","title":"connection  <code>async</code>","text":"<pre><code>connection(\n    **kwargs: str,\n) -&gt; collections.abc.AsyncIterator[mug.EmberMug]\n</code></pre> <p>Establish a connection and close automatically.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>@contextlib.asynccontextmanager\nasync def connection(self, **kwargs: str) -&gt; AsyncIterator[EmberMug]:\n    \"\"\"Establish a connection and close automatically.\"\"\"\n    self.set_client_options(**kwargs)\n    # This will happen automatically, but calling it now will give us immediate feedback\n    await self._ensure_connection()\n    yield self\n    await self.disconnect()\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect(expected: bool = True) -&gt; None\n</code></pre> <p>Disconnect from mug and stop listening to notifications.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def disconnect(self, expected: bool = True) -&gt; None:\n    \"\"\"Disconnect from mug and stop listening to notifications.\"\"\"\n    logger.debug(\"%s disconnect called\", \"Expected\" if expected else \"Unexpected\")\n    self._expected_disconnect = expected\n    if self._client and self._client.is_connected:\n        async with self._connect_lock:\n            await self.unsubscribe()\n            await self._client.disconnect()\n    self._client = None  # type: ignore[assignment]\n    self._expected_disconnect = False\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.discover_services","title":"discover_services  <code>async</code>","text":"<pre><code>discover_services() -&gt; dict[str, typing.Any]\n</code></pre> <p>Discover services for development or debugging.</p> <p>Call discover_services with this client, ensuring the connection is active first.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def discover_services(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Discover services for development or debugging.\n\n    Call discover_services with this client, ensuring the connection is active first.\n    \"\"\"\n    self._check_operation_lock()\n    async with self._operation_lock:\n        await self._ensure_connection()\n        return await discover_services(self._client)\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.ensure_correct_unit","title":"ensure_correct_unit  <code>async</code>","text":"<pre><code>ensure_correct_unit() -&gt; None\n</code></pre> <p>Set mug unit if it's not what we want.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def ensure_correct_unit(self) -&gt; None:\n    \"\"\"Set mug unit if it's not what we want.\"\"\"\n    desired = TemperatureUnit.CELSIUS if self.data.use_metric else TemperatureUnit.FAHRENHEIT\n    if self.data.temperature_unit != desired:\n        await self.set_temperature_unit(desired)\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.get_battery","title":"get_battery  <code>async</code>","text":"<pre><code>get_battery() -&gt; mug.data.BatteryInfo\n</code></pre> <p>Get Battery percent from mug gatt.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def get_battery(self) -&gt; BatteryInfo:\n    \"\"\"Get Battery percent from mug gatt.\"\"\"\n    return BatteryInfo.from_bytes(await self._read(MugCharacteristic.BATTERY))\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.get_battery_voltage","title":"get_battery_voltage  <code>async</code>","text":"<pre><code>get_battery_voltage() -&gt; int\n</code></pre> <p>Get voltage and charge time.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def get_battery_voltage(self) -&gt; int:\n    \"\"\"Get voltage and charge time.\"\"\"\n    battery_voltage_bytes = await self._read(MugCharacteristic.CONTROL_REGISTER_DATA)\n    return bytes_to_big_int(battery_voltage_bytes[:1])\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.get_current_temp","title":"get_current_temp  <code>async</code>","text":"<pre><code>get_current_temp() -&gt; float\n</code></pre> <p>Get current temp from mug gatt.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def get_current_temp(self) -&gt; float:\n    \"\"\"Get current temp from mug gatt.\"\"\"\n    temp_bytes = await self._read(MugCharacteristic.CURRENT_TEMPERATURE)\n    return temp_from_bytes(temp_bytes, self.data.use_metric)\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.get_date_time_zone","title":"get_date_time_zone  <code>async</code>","text":"<pre><code>get_date_time_zone() -&gt; datetime.datetime | None\n</code></pre> <p>Get date and time zone.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def get_date_time_zone(self) -&gt; datetime | None:\n    \"\"\"Get date and time zone.\"\"\"\n    date_time_zone_bytes = await self._read(MugCharacteristic.DATE_TIME_AND_ZONE)\n    time_value = bytes_to_big_int(date_time_zone_bytes[:4])\n    return datetime.fromtimestamp(time_value, UTC) if time_value &gt; 0 else None\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.get_dsk","title":"get_dsk  <code>async</code>","text":"<pre><code>get_dsk() -&gt; str\n</code></pre> <p>Get mug dsk from gatt.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def get_dsk(self) -&gt; str:\n    \"\"\"Get mug dsk from gatt.\"\"\"\n    try:\n        return decode_byte_string(await self._read(MugCharacteristic.DSK))\n    except BleakError as e:\n        logger.debug(\"Unable to read DSK: %s\", e)\n    return \"\"\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.get_firmware","title":"get_firmware  <code>async</code>","text":"<pre><code>get_firmware() -&gt; mug.data.MugFirmwareInfo\n</code></pre> <p>Get firmware info.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def get_firmware(self) -&gt; MugFirmwareInfo:\n    \"\"\"Get firmware info.\"\"\"\n    return MugFirmwareInfo.from_bytes(await self._read(MugCharacteristic.FIRMWARE))\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.get_led_colour","title":"get_led_colour  <code>async</code>","text":"<pre><code>get_led_colour() -&gt; mug.data.Colour\n</code></pre> <p>Get RGBA colours from mug gatt.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>@require_attribute(\"led_colour\")\nasync def get_led_colour(self) -&gt; Colour:\n    \"\"\"Get RGBA colours from mug gatt.\"\"\"\n    colour_data = await self._read(MugCharacteristic.LED)\n    return Colour(*bytearray(colour_data))\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.get_liquid_level","title":"get_liquid_level  <code>async</code>","text":"<pre><code>get_liquid_level() -&gt; int\n</code></pre> <p>Get liquid level from mug gatt.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def get_liquid_level(self) -&gt; int:\n    \"\"\"Get liquid level from mug gatt.\"\"\"\n    liquid_level_bytes = await self._read(MugCharacteristic.LIQUID_LEVEL)\n    return bytes_to_little_int(liquid_level_bytes)\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.get_liquid_state","title":"get_liquid_state  <code>async</code>","text":"<pre><code>get_liquid_state() -&gt; mug.consts.LiquidState\n</code></pre> <p>Get liquid state from mug gatt.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def get_liquid_state(self) -&gt; LiquidState:\n    \"\"\"Get liquid state from mug gatt.\"\"\"\n    liquid_state_bytes = await self._read(MugCharacteristic.LIQUID_STATE)\n    state = bytes_to_little_int(liquid_state_bytes)\n    return LiquidState(state)\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.get_meta","title":"get_meta  <code>async</code>","text":"<pre><code>get_meta() -&gt; mug.data.MugMeta\n</code></pre> <p>Fetch Meta info from the mug (Serial number and ID).</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def get_meta(self) -&gt; MugMeta:\n    \"\"\"Fetch Meta info from the mug (Serial number and ID).\"\"\"\n    return MugMeta.from_bytes(await self._read(MugCharacteristic.MUG_ID))\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.get_name","title":"get_name  <code>async</code>","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>Get mug name from gatt.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>@require_attribute(\"name\")\nasync def get_name(self) -&gt; str:\n    \"\"\"Get mug name from gatt.\"\"\"\n    name_bytes: bytearray = await self._read(MugCharacteristic.MUG_NAME)\n    return bytes(name_bytes).decode(\"utf8\")\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.get_target_temp","title":"get_target_temp  <code>async</code>","text":"<pre><code>get_target_temp() -&gt; float\n</code></pre> <p>Get target temp form mug gatt.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def get_target_temp(self) -&gt; float:\n    \"\"\"Get target temp form mug gatt.\"\"\"\n    temp_bytes = await self._read(MugCharacteristic.TARGET_TEMPERATURE)\n    return temp_from_bytes(temp_bytes, self.data.use_metric)\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.get_temperature_unit","title":"get_temperature_unit  <code>async</code>","text":"<pre><code>get_temperature_unit() -&gt; mug.consts.TemperatureUnit\n</code></pre> <p>Get mug temp unit.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def get_temperature_unit(self) -&gt; TemperatureUnit:\n    \"\"\"Get mug temp unit.\"\"\"\n    unit_bytes = await self._read(MugCharacteristic.TEMPERATURE_UNIT)\n    if bytes_to_little_int(unit_bytes) == 0:\n        return TemperatureUnit.CELSIUS\n    return TemperatureUnit.FAHRENHEIT\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.get_udsk","title":"get_udsk  <code>async</code>","text":"<pre><code>get_udsk() -&gt; str | None\n</code></pre> <p>Get mug udsk from gatt.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def get_udsk(self) -&gt; str | None:\n    \"\"\"Get mug udsk from gatt.\"\"\"\n    try:\n        data = await self._read(MugCharacteristic.UDSK)\n        if data == bytearray([0] * 20):\n            return None\n        return decode_byte_string(data)\n    except (BleakError, ValueError) as e:\n        logger.debug(\"Unable to read UDSK: %s\", e)\n    return None\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.get_volume_level","title":"get_volume_level  <code>async</code>","text":"<pre><code>get_volume_level() -&gt; mug.consts.VolumeLevel | None\n</code></pre> <p>Get volume level from mug gatt.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>@require_attribute(\"volume_level\")\nasync def get_volume_level(self) -&gt; VolumeLevel | None:\n    \"\"\"Get volume level from mug gatt.\"\"\"\n    volume_bytes = await self._read(MugCharacteristic.VOLUME)\n    volume_int = bytes_to_little_int(volume_bytes)\n    return VolumeLevel.from_state(volume_int)\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.has_attribute","title":"has_attribute","text":"<pre><code>has_attribute(attribute: str) -&gt; bool\n</code></pre> <p>Check whether the device has the given attribute.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>def has_attribute(self, attribute: str) -&gt; bool:\n    \"\"\"Check whether the device has the given attribute.\"\"\"\n    return attribute in self.data.model_info.device_attributes\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.register_callback","title":"register_callback","text":"<pre><code>register_callback(\n    callback: collections.abc.Callable[\n        [mug.data.MugData], None\n    ],\n) -&gt; collections.abc.Callable[[], None]\n</code></pre> <p>Register a callback to be called when the state changes.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>def register_callback(self, callback: Callable[[MugData], None]) -&gt; Callable[[], None]:\n    \"\"\"Register a callback to be called when the state changes.\"\"\"\n    if existing_unregister_callback := self._callbacks.get(callback):\n        logger.debug(\"Callback %s already registered\", callback)\n        return existing_unregister_callback\n\n    def unregister_callback() -&gt; None:\n        if callback in self._callbacks:\n            del self._callbacks[callback]\n        logger.debug(\"Unregistered callback: %s\", callback)\n\n    self._callbacks[callback] = unregister_callback\n    logger.debug(\"Registered callback: %s\", callback)\n    return unregister_callback\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.set_client_options","title":"set_client_options","text":"<pre><code>set_client_options(**kwargs: str) -&gt; None\n</code></pre> <p>Update options in case they need to overriden in some cases.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>def set_client_options(self, **kwargs: str) -&gt; None:\n    \"\"\"Update options in case they need to overriden in some cases.\"\"\"\n    if kwargs.get(\"adapter\") and IS_LINUX is False:\n        msg = \"The adapter option is only valid for the Linux BlueZ Backend.\"\n        raise ValueError(msg)\n    self._client_kwargs = {**kwargs}\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.set_led_colour","title":"set_led_colour  <code>async</code>","text":"<pre><code>set_led_colour(colour: mug.data.Colour) -&gt; None\n</code></pre> <p>Set new target temp for mug.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>@require_attribute(\"led_colour\")\nasync def set_led_colour(self, colour: Colour) -&gt; None:\n    \"\"\"Set new target temp for mug.\"\"\"\n    await self._write(MugCharacteristic.LED, colour.as_bytearray())\n    self.data.led_colour = colour\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.set_name","title":"set_name  <code>async</code>","text":"<pre><code>set_name(name: str) -&gt; None\n</code></pre> <p>Assign new name to mug.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>@require_attribute(\"name\")\nasync def set_name(self, name: str) -&gt; None:\n    \"\"\"Assign new name to mug.\"\"\"\n    if MUG_NAME_REGEX.match(name) is None:\n        msg = \"Name cannot contain any special characters and must be 16 characters or less\"\n        raise ValueError(msg)\n    await self._write(MugCharacteristic.MUG_NAME, bytearray(name.encode(\"utf8\")))\n    self.data.name = name\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.set_target_temp","title":"set_target_temp  <code>async</code>","text":"<pre><code>set_target_temp(target_temp: float) -&gt; None\n</code></pre> <p>Set new target temp for mug.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def set_target_temp(self, target_temp: float) -&gt; None:\n    \"\"\"Set new target temp for mug.\"\"\"\n    unit = TemperatureUnit.CELSIUS if self.data.use_metric else TemperatureUnit.FAHRENHEIT\n    min_temp, max_temp = MIN_MAX_TEMPS[unit]\n    if target_temp != 0 and not (min_temp &lt;= target_temp &lt;= max_temp):\n        raise ValueError(f\"Temperature should be between {min_temp} and {max_temp} or 0.\")\n\n    if self.data.use_metric is False:\n        target_temp = convert_temp_to_celsius(target_temp)\n\n    target = bytearray(int(target_temp / 0.01).to_bytes(2, \"little\"))\n    await self._write(MugCharacteristic.TARGET_TEMPERATURE, target)\n    self.data.target_temp = target_temp\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.set_temperature_unit","title":"set_temperature_unit  <code>async</code>","text":"<pre><code>set_temperature_unit(\n    unit: (\n        typing.Literal[\"\u00b0C\", \"\u00b0F\"]\n        | mug.consts.TemperatureUnit\n        | enum.Enum\n    ),\n) -&gt; None\n</code></pre> <p>Set mug unit.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def set_temperature_unit(self, unit: Literal[\"\u00b0C\", \"\u00b0F\"] | TemperatureUnit | Enum) -&gt; None:\n    \"\"\"Set mug unit.\"\"\"\n    text_unit = unit.value if isinstance(unit, Enum) else unit\n    unit_bytes = bytearray([1 if text_unit == TemperatureUnit.FAHRENHEIT else 0])\n    await self._write(MugCharacteristic.TEMPERATURE_UNIT, unit_bytes)\n    self.data.temperature_unit = TemperatureUnit(unit)\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.set_udsk","title":"set_udsk  <code>async</code>","text":"<pre><code>set_udsk(udsk: str) -&gt; None\n</code></pre> <p>Attempt to write udsk.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def set_udsk(self, udsk: str) -&gt; None:\n    \"\"\"Attempt to write udsk.\"\"\"\n    await self._write(MugCharacteristic.UDSK, bytearray(encode_byte_string(udsk)))\n    self.data.udsk = udsk\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.set_volume_level","title":"set_volume_level  <code>async</code>","text":"<pre><code>set_volume_level(\n    volume: int | mug.consts.VolumeLevel,\n) -&gt; None\n</code></pre> <p>Set volume_level on Travel Mug.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>@require_attribute(\"volume_level\")\nasync def set_volume_level(self, volume: int | VolumeLevel) -&gt; None:\n    \"\"\"Set volume_level on Travel Mug.\"\"\"\n    if not isinstance(volume, VolumeLevel) and isinstance(volume, int) and volume not in (0, 1, 2):\n        msg = \"Volume level value should be 0, 1, 2 or a VolumeLevel enum\"\n        raise ValueError(msg)\n    volume_level = volume if isinstance(volume, VolumeLevel) else VolumeLevel.from_state(volume)\n    await self._write(MugCharacteristic.VOLUME, bytearray([volume_level.state]))\n    self.data.volume_level = volume_level\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.subscribe","title":"subscribe  <code>async</code>","text":"<pre><code>subscribe() -&gt; None\n</code></pre> <p>Subscribe to notifications from the mug.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def subscribe(self) -&gt; None:\n    \"\"\"Subscribe to notifications from the mug.\"\"\"\n    try:\n        logger.info(\"Subscribe to Push Events\")\n        await self._client.start_notify(MugCharacteristic.PUSH_EVENT.uuid, self._notify_callback)\n        if self.debug:\n            await self._client.start_notify(MugCharacteristic.STATISTICS.uuid, self._notify_callback)\n    except Exception as e:\n        logger.warning(\"Failed to subscribe to state attr: %s\", e)\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.unsubscribe","title":"unsubscribe  <code>async</code>","text":"<pre><code>unsubscribe() -&gt; None\n</code></pre> <p>Unsubscribe from Mug notifications.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def unsubscribe(self) -&gt; None:\n    \"\"\"Unsubscribe from Mug notifications.\"\"\"\n    logger.debug(\"Unsubscribe called\")\n    if not self._client:\n        return\n    with contextlib.suppress(BleakError):\n        await self._client.stop_notify(MugCharacteristic.PUSH_EVENT.uuid)\n        if self.debug:\n            await self._client.stop_notify(MugCharacteristic.STATISTICS.uuid)\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.update_all","title":"update_all  <code>async</code>","text":"<pre><code>update_all() -&gt; list[mug.data.Change]\n</code></pre> <p>Update all standard attributes.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def update_all(self) -&gt; list[Change]:\n    \"\"\"Update all standard attributes.\"\"\"\n    return await self._update_multiple(\n        self.data.model_info.device_attributes - INITIAL_ATTRS,\n    )\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.update_initial","title":"update_initial  <code>async</code>","text":"<pre><code>update_initial() -&gt; list[mug.data.Change]\n</code></pre> <p>Update attributes that don't normally change and don't need to be regularly updated.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def update_initial(self) -&gt; list[Change]:\n    \"\"\"Update attributes that don't normally change and don't need to be regularly updated.\"\"\"\n    return await self._update_multiple(INITIAL_ATTRS)\n</code></pre>"},{"location":"api/mug/#mug.EmberMug.update_queued_attributes","title":"update_queued_attributes  <code>async</code>","text":"<pre><code>update_queued_attributes() -&gt; list[mug.data.Change]\n</code></pre> <p>Update all attributes in queue.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>async def update_queued_attributes(self) -&gt; list[Change]:\n    \"\"\"Update all attributes in queue.\"\"\"\n    logger.debug(\"Updating queued attributes: %s\", self._queued_updates)\n    if not self._queued_updates:\n        return []\n    queued_updates = set(self._queued_updates)\n    self._queued_updates.clear()\n    await self._ensure_connection()\n    changes = self.data.update_info(**{attr: await getattr(self, f\"get_{attr}\")() for attr in queued_updates})\n    if changes:\n        self._fire_callbacks()\n    return changes\n</code></pre>"},{"location":"api/mug/#mug-functions","title":"Functions","text":""},{"location":"api/mug/#mug.require_attribute","title":"require_attribute","text":"<pre><code>require_attribute(\n    attr_name: str,\n) -&gt; collections.abc.Callable[\n    [\n        collections.abc.Callable[\n            typing.Concatenate[mug.EmberMug, mug.P],\n            collections.abc.Awaitable[mug.T],\n        ]\n    ],\n    collections.abc.Callable[\n        typing.Concatenate[mug.EmberMug, mug.P],\n        collections.abc.Awaitable[mug.T],\n    ],\n]\n</code></pre> <p>Require an attribute to be available on the device.</p> Source code in <code>ember_mug/mug.py</code> <pre><code>def require_attribute(\n    attr_name: str,\n) -&gt; Callable[[Callable[Concatenate[EmberMug, P], Awaitable[T]]], Callable[Concatenate[EmberMug, P], Awaitable[T]]]:\n    \"\"\"Require an attribute to be available on the device.\"\"\"\n\n    def decorator(\n        func: Callable[Concatenate[EmberMug, P], Awaitable[T]],\n    ) -&gt; Callable[Concatenate[EmberMug, P], Awaitable[T]]:\n        \"\"\"Inner decorator.\"\"\"\n\n        async def wrapper(self: EmberMug, *args: P.args, **kwargs: P.kwargs) -&gt; T:\n            if self.has_attribute(attr_name) is False:\n                device_type = self.data.model_info.device_type.value\n                raise NotImplementedError(\n                    f\"The {device_type} does not have the {attr_name} attribute\",\n                )\n            return await func(self, *args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/scanner/","title":"scanner","text":""},{"location":"api/scanner/#scanner","title":"scanner","text":"<p>Scanning tools for finding mugs.</p>"},{"location":"api/scanner/#scanner-attributes","title":"Attributes","text":""},{"location":"api/scanner/#scanner.DEFAULT_TIMEOUT","title":"DEFAULT_TIMEOUT  <code>module-attribute</code>","text":"<pre><code>DEFAULT_TIMEOUT = 30\n</code></pre>"},{"location":"api/scanner/#scanner.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = logging.getLogger(__name__)\n</code></pre>"},{"location":"api/scanner/#scanner-classes","title":"Classes","text":""},{"location":"api/scanner/#scanner.ScannerKwargs","title":"ScannerKwargs","text":"<p>               Bases: <code>typing.TypedDict</code></p> <p>Optional kwargs for scanner.</p> Source code in <code>ember_mug/scanner.py</code> <pre><code>class ScannerKwargs(TypedDict):\n    \"\"\"Optional kwargs for scanner.\"\"\"\n\n    adapter: NotRequired[str]\n    service_uuids: NotRequired[list[str]]\n</code></pre>"},{"location":"api/scanner/#scanner.ScannerKwargs-attributes","title":"Attributes","text":""},{"location":"api/scanner/#scanner.ScannerKwargs.adapter","title":"adapter  <code>instance-attribute</code>","text":"<pre><code>adapter: typing.NotRequired[str]\n</code></pre>"},{"location":"api/scanner/#scanner.ScannerKwargs.service_uuids","title":"service_uuids  <code>instance-attribute</code>","text":"<pre><code>service_uuids: typing.NotRequired[list[str]]\n</code></pre>"},{"location":"api/scanner/#scanner-functions","title":"Functions","text":""},{"location":"api/scanner/#scanner.build_scanner_kwargs","title":"build_scanner_kwargs","text":"<pre><code>build_scanner_kwargs(\n    adapter: str | None = None,\n    *,\n    service_uuids: list[str] | None = None\n) -&gt; scanner.ScannerKwargs\n</code></pre> <p>Add Adapter to kwargs for scanner if specified and using BlueZ.</p> Source code in <code>ember_mug/scanner.py</code> <pre><code>def build_scanner_kwargs(adapter: str | None = None, *, service_uuids: list[str] | None = None) -&gt; ScannerKwargs:\n    \"\"\"Add Adapter to kwargs for scanner if specified and using BlueZ.\"\"\"\n    if adapter and IS_LINUX is not True:\n        msg = \"The adapter option is only valid for the Linux BlueZ Backend.\"\n        raise ValueError(msg)\n    kwargs = {\"service_uuids\": service_uuids} if service_uuids else {}\n    return cast(\"ScannerKwargs\", kwargs | {\"adapter\": adapter} if adapter else kwargs)\n</code></pre>"},{"location":"api/scanner/#scanner.discover_devices","title":"discover_devices  <code>async</code>","text":"<pre><code>discover_devices(\n    mac: str | None = None,\n    adapter: str | None = None,\n    wait: int = 5,\n) -&gt; list[\n    tuple[\n        bleak.backends.device.BLEDevice,\n        bleak.backends.scanner.AdvertisementData,\n    ]\n]\n</code></pre> <p>Discover new devices in pairing mode.</p>"},{"location":"api/scanner/#scanner.discover_devices--example","title":"Example:","text":"<pre><code>```python\ndevices = await discover_devices()\nfor device, advertisement in devices:\n    print(device.address, advertisement)\n```\n</code></pre> Source code in <code>ember_mug/scanner.py</code> <pre><code>async def discover_devices(\n    mac: str | None = None,\n    adapter: str | None = None,\n    wait: int = 5,\n) -&gt; list[tuple[BLEDevice, AdvertisementData]]:\n    \"\"\"\n    Discover new devices in pairing mode.\n\n    Example:\n    -------\n        ```python\n        devices = await discover_devices()\n        for device, advertisement in devices:\n            print(device.address, advertisement)\n        ```\n\n    \"\"\"\n    async with BleakScanner(**build_scanner_kwargs(adapter, service_uuids=DEVICE_SERVICE_UUIDS)) as scanner:\n        await asyncio.sleep(wait)\n        return [\n            (d, a)\n            for (d, a) in scanner.discovered_devices_and_advertisement_data.values()\n            if mac is None or d.address.lower() == mac.lower()\n        ]\n</code></pre>"},{"location":"api/scanner/#scanner.find_device","title":"find_device  <code>async</code>","text":"<pre><code>find_device(\n    mac: str | None = None,\n    adapter: str | None = None,\n    timeout: int = scanner.DEFAULT_TIMEOUT,\n) -&gt; (\n    tuple[\n        bleak.backends.device.BLEDevice,\n        bleak.backends.scanner.AdvertisementData,\n    ]\n    | tuple[None, None]\n)\n</code></pre> <p>Find a device that has previously been discovered.</p>"},{"location":"api/scanner/#scanner.find_device--example","title":"Example:","text":"<pre><code>```python\ndevice = await find_device(\"my:mac:addr\")\n```\n</code></pre> Source code in <code>ember_mug/scanner.py</code> <pre><code>async def find_device(\n    mac: str | None = None,\n    adapter: str | None = None,\n    timeout: int = DEFAULT_TIMEOUT,  # noqa: ASYNC109\n) -&gt; tuple[BLEDevice, AdvertisementData] | tuple[None, None]:\n    \"\"\"\n    Find a device that has previously been discovered.\n\n    Example:\n    -------\n        ```python\n        device = await find_device(\"my:mac:addr\")\n        ```\n\n    \"\"\"\n    if mac is not None:\n        mac = mac.lower()\n    async with BleakScanner(**build_scanner_kwargs(adapter)) as scanner:\n        with contextlib.suppress(asyncio.TimeoutError):\n            async with asyncio.timeout(timeout):\n                async for device, advertisement in scanner.advertisement_data():\n                    if (not mac and device.name and device.name.startswith(\"Ember\")) or (\n                        mac and device.address.lower() == mac\n                    ):\n                        return device, advertisement\n    return None, None\n</code></pre>"},{"location":"api/utils/","title":"utils","text":""},{"location":"api/utils/#utils","title":"utils","text":"<p>Helpful utils for processing mug data.</p>"},{"location":"api/utils/#utils-attributes","title":"Attributes","text":""},{"location":"api/utils/#utils.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = logging.getLogger(__name__)\n</code></pre>"},{"location":"api/utils/#utils-functions","title":"Functions","text":""},{"location":"api/utils/#utils.bytes_to_big_int","title":"bytes_to_big_int","text":"<pre><code>bytes_to_big_int(\n    data: bytearray | bytes, signed: bool = False\n) -&gt; int\n</code></pre> <p>Convert bytes to big int.</p> Source code in <code>ember_mug/utils.py</code> <pre><code>def bytes_to_big_int(data: bytearray | bytes, signed: bool = False) -&gt; int:\n    \"\"\"Convert bytes to big int.\"\"\"\n    return int.from_bytes(data, byteorder=\"big\", signed=signed)\n</code></pre>"},{"location":"api/utils/#utils.bytes_to_little_int","title":"bytes_to_little_int","text":"<pre><code>bytes_to_little_int(data: bytearray | bytes) -&gt; int\n</code></pre> <p>Convert bytes to little int.</p> Source code in <code>ember_mug/utils.py</code> <pre><code>def bytes_to_little_int(data: bytearray | bytes) -&gt; int:\n    \"\"\"Convert bytes to little int.\"\"\"\n    return int.from_bytes(data, byteorder=\"little\", signed=False)\n</code></pre>"},{"location":"api/utils/#utils.convert_temp_to_celsius","title":"convert_temp_to_celsius","text":"<pre><code>convert_temp_to_celsius(temp: float) -&gt; float\n</code></pre> <p>Convert to Celsius.</p> Source code in <code>ember_mug/utils.py</code> <pre><code>def convert_temp_to_celsius(temp: float) -&gt; float:\n    \"\"\"Convert to Celsius.\"\"\"\n    return (temp - 32) * 5 / 9\n</code></pre>"},{"location":"api/utils/#utils.convert_temp_to_fahrenheit","title":"convert_temp_to_fahrenheit","text":"<pre><code>convert_temp_to_fahrenheit(temp: float) -&gt; float\n</code></pre> <p>Convert to fahrenheit.</p> Source code in <code>ember_mug/utils.py</code> <pre><code>def convert_temp_to_fahrenheit(temp: float) -&gt; float:\n    \"\"\"Convert to fahrenheit.\"\"\"\n    return (temp * 9 / 5) + 32\n</code></pre>"},{"location":"api/utils/#utils.decode_byte_string","title":"decode_byte_string","text":"<pre><code>decode_byte_string(data: bytes | bytearray) -&gt; str\n</code></pre> <p>Convert bytes to text as Ember expects.</p> Source code in <code>ember_mug/utils.py</code> <pre><code>def decode_byte_string(data: bytes | bytearray) -&gt; str:\n    \"\"\"Convert bytes to text as Ember expects.\"\"\"\n    if not data:\n        return \"\"\n    with contextlib.suppress(ValueError):\n        b64_as_str = base64.encodebytes(data).decode()\n        return re.sub(\"[\\r\\n]\", \"\", b64_as_str)\n    logger.warning('Failed to decode bytes \"%s\". Forcing to string.', data)\n    return str(data)\n</code></pre>"},{"location":"api/utils/#utils.discover_services","title":"discover_services  <code>async</code>","text":"<pre><code>discover_services(\n    client: bleak.BleakClient,\n) -&gt; dict[str, typing.Any]\n</code></pre> <p>Log all services and all values for debugging/development.</p> Source code in <code>ember_mug/utils.py</code> <pre><code>async def discover_services(client: BleakClient) -&gt; dict[str, Any]:\n    \"\"\"Log all services and all values for debugging/development.\"\"\"\n    logger.info(\"Logging all services that were discovered\")\n    services: dict[str, Any] = {}\n    for service in client.services:\n        logger.debug(\"[Service] %s: %s\", service.uuid, service.description)\n        characteristics: dict[str, Any] = {}\n        services[service.uuid] = {\n            \"uuid\": service.uuid,\n            \"characteristics\": characteristics,\n        }\n        for characteristic in service.characteristics:\n            value: bytes | BleakError | None = None\n            if \"read\" in characteristic.properties:\n                try:\n                    value = bytes(await client.read_gatt_char(characteristic.uuid))\n                except BleakError as e:\n                    value = e\n            logger.debug(\n                \"\\t[Characteristic] %s: %s | Description: %s | Value: '%s'\",\n                characteristic.uuid,\n                \",\".join(characteristic.properties),\n                characteristic.description,\n                value,\n            )\n            descriptors: list[dict[str, Any]] = []\n            characteristics[characteristic.uuid] = {\n                \"uuid\": characteristic.uuid,\n                \"properties\": characteristic.properties,\n                \"value\": value,\n                \"descriptors\": descriptors,\n            }\n            for descriptor in characteristic.descriptors:\n                value = bytes(await client.read_gatt_descriptor(descriptor.handle))\n                logger.debug(\n                    \"\\t\\t[Descriptor] %s: Handle: %s | Value: '%s'\",\n                    descriptor.uuid,\n                    descriptor.handle,\n                    value,\n                )\n                descriptors.append(\n                    {\n                        \"uuid\": descriptor.uuid,\n                        \"handle\": descriptor.handle,\n                        \"value\": value,\n                    },\n                )\n    return services\n</code></pre>"},{"location":"api/utils/#utils.encode_byte_string","title":"encode_byte_string","text":"<pre><code>encode_byte_string(data: str) -&gt; bytes\n</code></pre> <p>Encode string from Ember Mug.</p> Source code in <code>ember_mug/utils.py</code> <pre><code>def encode_byte_string(data: str) -&gt; bytes:\n    \"\"\"Encode string from Ember Mug.\"\"\"\n    return re.sub(b\"[\\r\\n]\", b\"\", base64.encodebytes(data.encode()))\n</code></pre>"},{"location":"api/utils/#utils.get_colour_from_int","title":"get_colour_from_int","text":"<pre><code>get_colour_from_int(\n    colour_id: int,\n) -&gt; ember_mug.consts.DeviceColour | None\n</code></pre> <p>Extrapolate device colour from integer in advertiser data.</p> Source code in <code>ember_mug/utils.py</code> <pre><code>def get_colour_from_int(colour_id: int) -&gt; DeviceColour | None:\n    \"\"\"Extrapolate device colour from integer in advertiser data.\"\"\"\n    if colour_id in (-127, -63, 1, 14, 65):\n        return DeviceColour.BLACK\n    if colour_id in (-126, -62, 2):\n        return DeviceColour.WHITE\n    if colour_id in (8, 11, -56, -63, -120, -117, -53):\n        return DeviceColour.RED\n    if colour_id in (-131, -125, -61, 3, 83):\n        return DeviceColour.COPPER\n    if colour_id in (-124, -60):\n        return DeviceColour.ROSE_GOLD\n    return {\n        -51: DeviceColour.SANDSTONE,\n        -52: DeviceColour.SAGE_GREEN,\n        -55: DeviceColour.GREY,\n        -57: DeviceColour.BLUE,\n        -122: DeviceColour.GOLD,\n        -123: DeviceColour.STAINLESS_STEEL,\n    }.get(colour_id)\n</code></pre>"},{"location":"api/utils/#utils.get_model_from_id_and_gen","title":"get_model_from_id_and_gen","text":"<pre><code>get_model_from_id_and_gen(\n    model_id: int, generation: int\n) -&gt; ember_mug.consts.DeviceModel | None\n</code></pre> <p>Extract model from identifier in advertiser data.</p> Source code in <code>ember_mug/utils.py</code> <pre><code>def get_model_from_id_and_gen(model_id: int, generation: int) -&gt; DeviceModel | None:\n    \"\"\"Extract model from identifier in advertiser data.\"\"\"\n    if model_id == 1:\n        return DeviceModel.MUG_1_10_OZ if generation &lt; 2 else DeviceModel.MUG_2_10_OZ\n    if model_id == 2:\n        return DeviceModel.MUG_1_14_OZ if generation &lt; 2 else DeviceModel.MUG_2_14_OZ\n    if model_id == 3:\n        return DeviceModel.TRAVEL_MUG_12_OZ\n    if model_id == 8:\n        return DeviceModel.CUP_6_OZ\n    if model_id == 9:\n        return DeviceModel.TUMBLER_16_OZ\n    return None\n</code></pre>"},{"location":"api/utils/#utils.get_model_from_single_int_and_services","title":"get_model_from_single_int_and_services","text":"<pre><code>get_model_from_single_int_and_services(\n    model_id: int, service_uuids: list[str]\n) -&gt; ember_mug.consts.DeviceModel | None\n</code></pre> <p>Extrapolate device model from integer in advertiser data.</p> Source code in <code>ember_mug/utils.py</code> <pre><code>def get_model_from_single_int_and_services(  # noqa PLR0911\n    model_id: int,\n    service_uuids: list[str],\n) -&gt; DeviceModel | None:\n    \"\"\"Extrapolate device model from integer in advertiser data.\"\"\"\n    if set(TRAVEL_MUG_SERVICE_UUIDS).intersection(service_uuids):\n        return DeviceModel.TRAVEL_MUG_12_OZ\n    if model_id in (1, 2, 3):\n        return DeviceModel.MUG_1_10_OZ\n    if model_id == 65:\n        return DeviceModel.MUG_1_14_OZ\n    if model_id in (-51, -63, -61, -62):\n        return DeviceModel.MUG_2_14_OZ\n    if model_id == -60:\n        return DeviceModel.CUP_6_OZ\n    if model_id in (-127, -126, -125, -124, -123, -122, -120, -117, -57, -56, -55, -53, -52, 83, 131):\n        return DeviceModel.MUG_2_10_OZ\n    return None\n</code></pre>"},{"location":"api/utils/#utils.get_model_info_from_advertiser_data","title":"get_model_info_from_advertiser_data","text":"<pre><code>get_model_info_from_advertiser_data(\n    advertisement: bleak.AdvertisementData,\n) -&gt; ember_mug.data.ModelInfo\n</code></pre> <p>Extract model info from manufacturer data in advertiser data.</p> Source code in <code>ember_mug/utils.py</code> <pre><code>def get_model_info_from_advertiser_data(advertisement: AdvertisementData) -&gt; ModelInfo:\n    \"\"\"Extract model info from manufacturer data in advertiser data.\"\"\"\n    from ember_mug.data import ModelInfo  # noqa: PLC0415\n\n    model_data = advertisement.manufacturer_data.get(EMBER_BLE_SIG, None)\n    if model_data is not None:\n        if len(model_data) &lt; 4:\n            model_id = bytes_to_big_int(model_data, signed=True)\n            return ModelInfo(\n                get_model_from_single_int_and_services(model_id, advertisement.service_uuids),\n                get_colour_from_int(model_id),\n            )\n        model_id, generation, colour_id = model_data[1:4]\n        return ModelInfo(\n            get_model_from_id_and_gen(model_id, generation),\n            get_colour_from_int(colour_id),\n        )\n    logger.debug(\n        \"Unable to reliably determine model info from advertiser data.\" \"Falling back to guessing based on name.\",\n    )\n    return ModelInfo(guess_model_from_name(advertisement.local_name))\n</code></pre>"},{"location":"api/utils/#utils.guess_model_from_name","title":"guess_model_from_name","text":"<pre><code>guess_model_from_name(\n    name: str | None,\n) -&gt; ember_mug.consts.DeviceModel | None\n</code></pre> <p>Guess model from BLE name.</p> Source code in <code>ember_mug/utils.py</code> <pre><code>def guess_model_from_name(name: str | None) -&gt; DeviceModel | None:\n    \"\"\"Guess model from BLE name.\"\"\"\n    if not name:\n        return None\n    if \"Travel\" in name:\n        return DeviceModel.TRAVEL_MUG_12_OZ\n    if \"Cup\" in name:\n        return DeviceModel.CUP_6_OZ\n    return DeviceModel.UNKNOWN_DEVICE\n</code></pre>"},{"location":"api/utils/#utils.temp_from_bytes","title":"temp_from_bytes","text":"<pre><code>temp_from_bytes(\n    temp_bytes: bytearray, metric: bool = True\n) -&gt; float\n</code></pre> <p>Get temperature from bytearray and convert to Fahrenheit if needed.</p> Source code in <code>ember_mug/utils.py</code> <pre><code>def temp_from_bytes(temp_bytes: bytearray, metric: bool = True) -&gt; float:\n    \"\"\"Get temperature from bytearray and convert to Fahrenheit if needed.\"\"\"\n    temp = float(bytes_to_little_int(temp_bytes)) * 0.01\n    if metric is False:\n        temp = convert_temp_to_fahrenheit(temp)\n    return round(temp, 2)\n</code></pre>"},{"location":"api/cli/","title":"cli","text":""},{"location":"api/cli/#cli","title":"cli","text":"<p>CLI Interface.</p>"},{"location":"api/cli/#cli-classes","title":"Classes","text":""},{"location":"api/cli/#cli.EmberMugCli","title":"EmberMugCli","text":"<p>Very simple CLI Interface to interact with a mug.</p> Source code in <code>ember_mug/cli/commands.py</code> <pre><code>class EmberMugCli:\n    \"\"\"Very simple CLI Interface to interact with a mug.\"\"\"\n\n    _commands: ClassVar[dict[str, Callable[[Namespace], Awaitable]]] = {\n        \"find\": find_device_cmd,\n        \"discover\": discover_cmd,\n        \"info\": fetch_info_cmd,\n        \"poll\": poll_device_cmd,\n        \"get\": get_device_value_cmd,\n        \"set\": set_device_value_cmd,\n    }\n\n    def __init__(self) -&gt; None:\n        \"\"\"Create parsers.\"\"\"\n        self.parser = ArgumentParser(prog=\"ember-mug\", description=\"CLI to interact with an Ember Mug\")\n        shared_parser = ArgumentParser(add_help=False)\n        shared_parser.add_argument(\n            \"-m\",\n            \"--mac\",\n            action=\"store\",\n            type=validate_mac,\n            help=\"Only look for this specific address\",\n        )\n        shared_parser.add_argument(\n            \"-d\",\n            \"--debug\",\n            action=\"store_true\",\n            help=\"Print extra information for development or debugging issues\",\n        )\n        shared_parser.add_argument(\n            \"--log-file\",\n            type=FileType(\"w\", encoding=\"utf-8\"),\n            nargs=\"?\",\n            default=sys.stdout,\n            help=\"File to write logs too (Will be overwritten)\",\n        )\n        shared_parser.add_argument(\"-r\", \"--raw\", help=\"No formatting. One value per line.\", action=\"store_true\")\n        if IS_LINUX is True:\n            # Only works on Linux with BlueZ so don't add for others.\n            shared_parser.add_argument(\n                \"-a\",\n                \"--adapter\",\n                action=\"store\",\n                help=\"Use this Bluetooth adapter instead of the default one (for Bluez)\",\n            )\n        subparsers = self.parser.add_subparsers(dest=\"command\", required=True)\n        subparsers.add_parser(\"find\", description=\"Find the first paired device\", parents=[shared_parser])\n        subparsers.add_parser(\"discover\", description=\"Discover devices in pairing mode\", parents=[shared_parser])\n        info_parsers = ArgumentParser(add_help=False)\n        info_parsers.add_argument(\"-e\", \"--extra\", help=\"Show extra info\", action=\"store_true\")\n        info_parsers.add_argument(\"--imperial\", help=\"Use Imperial units\", action=\"store_true\")\n        subparsers.add_parser(\"info\", description=\"Fetch all info from device\", parents=[shared_parser, info_parsers])\n        subparsers.add_parser(\"poll\", description=\"Poll device for information\", parents=[shared_parser, info_parsers])\n        get_parser = subparsers.add_parser(\"get\", description=\"Get mug value\", parents=[shared_parser, info_parsers])\n        get_parser.add_argument(dest=\"attributes\", metavar=\"ATTRIBUTE\", choices=get_attribute_names, nargs=\"+\")\n        set_parser = subparsers.add_parser(\"set\", description=\"Set mug value\", parents=[shared_parser, info_parsers])\n        set_parser.add_argument(\"--name\", help=\"Name\", required=False)\n        set_parser.add_argument(\"--target-temp\", help=\"Target Temperature\", type=float, required=False)\n        set_parser.add_argument(\"--temperature-unit\", help=\"Temperature Unit\", choices=[\"C\", \"F\"], required=False)\n        set_parser.add_argument(\"--led-colour\", help=\"LED Colour\", type=colour_type, required=False)\n        set_parser.add_argument(\n            \"--volume-level\",\n            help=\"Volume Level\",\n            choices=[v.value for v in VolumeLevel],\n            required=False,\n        )\n\n    async def run(self) -&gt; None:\n        \"\"\"Run the specified command based on subparser.\"\"\"\n        args = self.parser.parse_args()\n        if IS_LINUX is False:\n            args.adapter = None  # Set for other platforms\n        if args.debug:\n            logging.basicConfig(\n                stream=args.log_file,\n                level=logging.DEBUG,\n                format=\"[%(asctime)s] %(levelname)s [%(filename)s.%(funcName)s:%(lineno)d] %(message)s\",\n            )\n        await self._commands[args.command](args)\n</code></pre>"},{"location":"api/cli/#cli.EmberMugCli-attributes","title":"Attributes","text":""},{"location":"api/cli/#cli.EmberMugCli.parser","title":"parser  <code>instance-attribute</code>","text":"<pre><code>parser = argparse.ArgumentParser(\n    prog=\"ember-mug\",\n    description=\"CLI to interact with an Ember Mug\",\n)\n</code></pre>"},{"location":"api/cli/#cli.EmberMugCli-functions","title":"Functions","text":""},{"location":"api/cli/#cli.EmberMugCli.run","title":"run  <code>async</code>","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Run the specified command based on subparser.</p> Source code in <code>ember_mug/cli/commands.py</code> <pre><code>async def run(self) -&gt; None:\n    \"\"\"Run the specified command based on subparser.\"\"\"\n    args = self.parser.parse_args()\n    if IS_LINUX is False:\n        args.adapter = None  # Set for other platforms\n    if args.debug:\n        logging.basicConfig(\n            stream=args.log_file,\n            level=logging.DEBUG,\n            format=\"[%(asctime)s] %(levelname)s [%(filename)s.%(funcName)s:%(lineno)d] %(message)s\",\n        )\n    await self._commands[args.command](args)\n</code></pre>"},{"location":"api/cli/#cli-functions","title":"Functions","text":""},{"location":"api/cli/#cli.run_cli","title":"run_cli","text":"<pre><code>run_cli() -&gt; None\n</code></pre> <p>Run the command line interface.</p> Source code in <code>ember_mug/cli/__init__.py</code> <pre><code>def run_cli() -&gt; None:\n    \"\"\"Run the command line interface.\"\"\"\n    cli = EmberMugCli()\n    try:\n        asyncio.run(cli.run())\n    except KeyboardInterrupt:\n        print(\"Exiting.\")\n</code></pre>"},{"location":"api/cli/commands/","title":"cli.commands","text":""},{"location":"api/cli/commands/#cli.commands","title":"cli.commands","text":"<p>CLI Interface.</p>"},{"location":"api/cli/commands/#cli.commands-attributes","title":"Attributes","text":""},{"location":"api/cli/commands/#cli.commands.all_attrs","title":"all_attrs  <code>module-attribute</code>","text":"<pre><code>all_attrs = list(ember_mug.consts.ATTR_LABELS) + list(\n    ember_mug.consts.EXTRA_ATTRS\n)\n</code></pre>"},{"location":"api/cli/commands/#cli.commands.get_attribute_names","title":"get_attribute_names  <code>module-attribute</code>","text":"<pre><code>get_attribute_names = [\n    (n.replace(\"_\", \"-\")) for n in cli.commands.all_attrs\n]\n</code></pre>"},{"location":"api/cli/commands/#cli.commands-classes","title":"Classes","text":""},{"location":"api/cli/commands/#cli.commands.EmberMugCli","title":"EmberMugCli","text":"<p>Very simple CLI Interface to interact with a mug.</p> Source code in <code>ember_mug/cli/commands.py</code> <pre><code>class EmberMugCli:\n    \"\"\"Very simple CLI Interface to interact with a mug.\"\"\"\n\n    _commands: ClassVar[dict[str, Callable[[Namespace], Awaitable]]] = {\n        \"find\": find_device_cmd,\n        \"discover\": discover_cmd,\n        \"info\": fetch_info_cmd,\n        \"poll\": poll_device_cmd,\n        \"get\": get_device_value_cmd,\n        \"set\": set_device_value_cmd,\n    }\n\n    def __init__(self) -&gt; None:\n        \"\"\"Create parsers.\"\"\"\n        self.parser = ArgumentParser(prog=\"ember-mug\", description=\"CLI to interact with an Ember Mug\")\n        shared_parser = ArgumentParser(add_help=False)\n        shared_parser.add_argument(\n            \"-m\",\n            \"--mac\",\n            action=\"store\",\n            type=validate_mac,\n            help=\"Only look for this specific address\",\n        )\n        shared_parser.add_argument(\n            \"-d\",\n            \"--debug\",\n            action=\"store_true\",\n            help=\"Print extra information for development or debugging issues\",\n        )\n        shared_parser.add_argument(\n            \"--log-file\",\n            type=FileType(\"w\", encoding=\"utf-8\"),\n            nargs=\"?\",\n            default=sys.stdout,\n            help=\"File to write logs too (Will be overwritten)\",\n        )\n        shared_parser.add_argument(\"-r\", \"--raw\", help=\"No formatting. One value per line.\", action=\"store_true\")\n        if IS_LINUX is True:\n            # Only works on Linux with BlueZ so don't add for others.\n            shared_parser.add_argument(\n                \"-a\",\n                \"--adapter\",\n                action=\"store\",\n                help=\"Use this Bluetooth adapter instead of the default one (for Bluez)\",\n            )\n        subparsers = self.parser.add_subparsers(dest=\"command\", required=True)\n        subparsers.add_parser(\"find\", description=\"Find the first paired device\", parents=[shared_parser])\n        subparsers.add_parser(\"discover\", description=\"Discover devices in pairing mode\", parents=[shared_parser])\n        info_parsers = ArgumentParser(add_help=False)\n        info_parsers.add_argument(\"-e\", \"--extra\", help=\"Show extra info\", action=\"store_true\")\n        info_parsers.add_argument(\"--imperial\", help=\"Use Imperial units\", action=\"store_true\")\n        subparsers.add_parser(\"info\", description=\"Fetch all info from device\", parents=[shared_parser, info_parsers])\n        subparsers.add_parser(\"poll\", description=\"Poll device for information\", parents=[shared_parser, info_parsers])\n        get_parser = subparsers.add_parser(\"get\", description=\"Get mug value\", parents=[shared_parser, info_parsers])\n        get_parser.add_argument(dest=\"attributes\", metavar=\"ATTRIBUTE\", choices=get_attribute_names, nargs=\"+\")\n        set_parser = subparsers.add_parser(\"set\", description=\"Set mug value\", parents=[shared_parser, info_parsers])\n        set_parser.add_argument(\"--name\", help=\"Name\", required=False)\n        set_parser.add_argument(\"--target-temp\", help=\"Target Temperature\", type=float, required=False)\n        set_parser.add_argument(\"--temperature-unit\", help=\"Temperature Unit\", choices=[\"C\", \"F\"], required=False)\n        set_parser.add_argument(\"--led-colour\", help=\"LED Colour\", type=colour_type, required=False)\n        set_parser.add_argument(\n            \"--volume-level\",\n            help=\"Volume Level\",\n            choices=[v.value for v in VolumeLevel],\n            required=False,\n        )\n\n    async def run(self) -&gt; None:\n        \"\"\"Run the specified command based on subparser.\"\"\"\n        args = self.parser.parse_args()\n        if IS_LINUX is False:\n            args.adapter = None  # Set for other platforms\n        if args.debug:\n            logging.basicConfig(\n                stream=args.log_file,\n                level=logging.DEBUG,\n                format=\"[%(asctime)s] %(levelname)s [%(filename)s.%(funcName)s:%(lineno)d] %(message)s\",\n            )\n        await self._commands[args.command](args)\n</code></pre>"},{"location":"api/cli/commands/#cli.commands.EmberMugCli-attributes","title":"Attributes","text":""},{"location":"api/cli/commands/#cli.commands.EmberMugCli.parser","title":"parser  <code>instance-attribute</code>","text":"<pre><code>parser = argparse.ArgumentParser(\n    prog=\"ember-mug\",\n    description=\"CLI to interact with an Ember Mug\",\n)\n</code></pre>"},{"location":"api/cli/commands/#cli.commands.EmberMugCli-functions","title":"Functions","text":""},{"location":"api/cli/commands/#cli.commands.EmberMugCli.run","title":"run  <code>async</code>","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Run the specified command based on subparser.</p> Source code in <code>ember_mug/cli/commands.py</code> <pre><code>async def run(self) -&gt; None:\n    \"\"\"Run the specified command based on subparser.\"\"\"\n    args = self.parser.parse_args()\n    if IS_LINUX is False:\n        args.adapter = None  # Set for other platforms\n    if args.debug:\n        logging.basicConfig(\n            stream=args.log_file,\n            level=logging.DEBUG,\n            format=\"[%(asctime)s] %(levelname)s [%(filename)s.%(funcName)s:%(lineno)d] %(message)s\",\n        )\n    await self._commands[args.command](args)\n</code></pre>"},{"location":"api/cli/commands/#cli.commands-functions","title":"Functions","text":""},{"location":"api/cli/commands/#cli.commands.colour_type","title":"colour_type","text":"<pre><code>colour_type(value: str) -&gt; ember_mug.data.Colour\n</code></pre> <p>Convert a hex or rgb colour to a Colour object.</p> Source code in <code>ember_mug/cli/commands.py</code> <pre><code>def colour_type(value: str) -&gt; Colour:\n    \"\"\"Convert a hex or rgb colour to a Colour object.\"\"\"\n    print(value)\n    if match := re.match(r\"#?([0-9a-f]{6}([0-9a-f]{2})?)\", value, re.IGNORECASE):\n        raw_colours = match.group(1)\n        colours = [\n            255 if (colour := raw_colours[i : i + 2]) is None else int(colour, 16)\n            for i in range(0, len(raw_colours), 2)\n        ]\n        return Colour(*colours)\n\n    with contextlib.suppress(ValueError, AssertionError):\n        colours = [int(v) for v in value.split(\",\")]\n        if len(colours) not in (3, 4):\n            raise ArgumentTypeError(\"Three or four values should be specified for colour\")\n        if not all(0 &lt;= c &lt;= 255 for c in colours):\n            raise ArgumentTypeError(\"Colour values must be between 0 and 255\")\n        return Colour(*colours)\n\n    msg = f'\"{value}\" is not a valid rgba or hex colour'\n    raise ArgumentTypeError(msg)\n</code></pre>"},{"location":"api/cli/commands/#cli.commands.discover_cmd","title":"discover_cmd  <code>async</code>","text":"<pre><code>discover_cmd(\n    args: argparse.Namespace,\n) -&gt; list[\n    tuple[\n        bleak.backends.device.BLEDevice,\n        bleak.AdvertisementData,\n    ]\n]\n</code></pre> <p>Discover new devices in pairing mode.</p> Source code in <code>ember_mug/cli/commands.py</code> <pre><code>async def discover_cmd(args: Namespace) -&gt; list[tuple[BLEDevice, AdvertisementData]]:\n    \"\"\"Discover new devices in pairing mode.\"\"\"\n    try:\n        mugs = await discover_devices(mac=args.mac)\n    except BleakError as e:\n        print(f\"An error occurred trying to discover devices: {e}\")\n        sys.exit(1)\n    if not mugs:\n        print('No devices were found. Be sure it is in pairing mode. Or use \"find\" if already paired.')\n        sys.exit(1)\n\n    for mug, advertisement in mugs:\n        if args.raw:\n            print(mug.address)\n        else:\n            model_info = get_model_info_from_advertiser_data(advertisement)\n            model_number = model_info.model.value if model_info.model else \"Unknown Model\"\n            print(f\"Found {model_info.device_type.value}:\", mug)\n            print(\"Name:\", advertisement.local_name)\n            print(\"Model:\", f\"{model_info.name} [{model_number}]\")\n            print(\"Colour:\", model_info.colour.value if model_info.colour else \"Unknown\")\n            print(\"Capacity:\", format_capacity(model_info.capacity))\n    return mugs\n</code></pre>"},{"location":"api/cli/commands/#cli.commands.fetch_info_cmd","title":"fetch_info_cmd  <code>async</code>","text":"<pre><code>fetch_info_cmd(args: argparse.Namespace) -&gt; None\n</code></pre> <p>Fetch all information from a mug and end.</p> Source code in <code>ember_mug/cli/commands.py</code> <pre><code>async def fetch_info_cmd(args: Namespace) -&gt; None:\n    \"\"\"Fetch all information from a mug and end.\"\"\"\n    mug = await get_device(args)\n    async with mug.connection(adapter=args.adapter):\n        if not args.raw:\n            print(\"Connected.\\nFetching Info\")\n        await mug.update_all()\n    print_info(mug)\n</code></pre>"},{"location":"api/cli/commands/#cli.commands.find_device_cmd","title":"find_device_cmd  <code>async</code>","text":"<pre><code>find_device_cmd(\n    args: argparse.Namespace,\n) -&gt; tuple[\n    bleak.backends.device.BLEDevice, bleak.AdvertisementData\n]\n</code></pre> <p>Find a single device that has already been paired.</p> Source code in <code>ember_mug/cli/commands.py</code> <pre><code>async def find_device_cmd(args: Namespace) -&gt; tuple[BLEDevice, AdvertisementData]:\n    \"\"\"Find a single device that has already been paired.\"\"\"\n    try:\n        device, advertisement = await find_device(mac=args.mac, adapter=args.adapter)\n    except BleakError as e:\n        print(f\"An error occurred trying to find a device: {e}\")\n        sys.exit(1)\n    if not device or not advertisement:\n        print(\"No device was found.\")\n        sys.exit(1)\n    if not args.raw:\n        print(\"Found device:\", device)\n    return device, advertisement\n</code></pre>"},{"location":"api/cli/commands/#cli.commands.get_device","title":"get_device  <code>async</code>","text":"<pre><code>get_device(\n    args: argparse.Namespace,\n) -&gt; ember_mug.mug.EmberMug\n</code></pre> <p>Help to get the devices based on command args.</p> Source code in <code>ember_mug/cli/commands.py</code> <pre><code>async def get_device(args: Namespace) -&gt; EmberMug:\n    \"\"\"Help to get the devices based on command args.\"\"\"\n    device, advertisement = await find_device_cmd(args)\n    mug = EmberMug(\n        device,\n        get_model_info_from_advertiser_data(advertisement),\n        use_metric=not args.imperial,\n        debug=args.debug,\n    )\n    if not args.raw:\n        print(\"Connecting...\")\n    return mug\n</code></pre>"},{"location":"api/cli/commands/#cli.commands.get_device_value_cmd","title":"get_device_value_cmd  <code>async</code>","text":"<pre><code>get_device_value_cmd(args: argparse.Namespace) -&gt; None\n</code></pre> <p>Get values from the mug and print them.</p> Source code in <code>ember_mug/cli/commands.py</code> <pre><code>async def get_device_value_cmd(args: Namespace) -&gt; None:\n    \"\"\"Get values from the mug and print them.\"\"\"\n    mug = await get_device(args)\n    data = {}\n    attributes = [a.replace(\"-\", \"_\") for a in args.attributes]\n    async with mug.connection(adapter=args.adapter):\n        for attr in attributes:\n            try:\n                value = await getattr(mug, f\"get_{attr}\")()\n            except NotImplementedError as e:\n                print(e)\n                sys.exit(1)\n            setattr(mug.data, attr, value)\n            data[attr] = value\n    if args.raw:\n        print(\"\\n\".join(str(v) for v in data.values()))\n    else:\n        print_table([(ATTR_LABELS.get(attr, attr), str(mug.data.get_formatted_attr(attr))) for attr in data])\n</code></pre>"},{"location":"api/cli/commands/#cli.commands.poll_device_cmd","title":"poll_device_cmd  <code>async</code>","text":"<pre><code>poll_device_cmd(args: argparse.Namespace) -&gt; None\n</code></pre> <p>Fetch all information and keep polling for changes.</p> Source code in <code>ember_mug/cli/commands.py</code> <pre><code>async def poll_device_cmd(args: Namespace) -&gt; None:\n    \"\"\"Fetch all information and keep polling for changes.\"\"\"\n    mug = await get_device(args)\n    async with mug.connection(adapter=args.adapter):\n        if not args.raw:\n            print(\"Connected.\\nFetching Info\")\n        await mug.update_all()\n        print_info(mug)\n        if not args.raw:\n            print(\"\\nWatching for changes\")\n        for _ in CommandLoop():\n            for _ in range(60):\n                await asyncio.sleep(1)\n                print_changes(await mug.update_queued_attributes(), mug.data.use_metric)\n            # Every minute do a full update\n            print_changes(await mug.update_all(), mug.data.use_metric)\n</code></pre>"},{"location":"api/cli/commands/#cli.commands.set_device_value_cmd","title":"set_device_value_cmd  <code>async</code>","text":"<pre><code>set_device_value_cmd(args: argparse.Namespace) -&gt; None\n</code></pre> <p>Set one or more values on the device.</p> Source code in <code>ember_mug/cli/commands.py</code> <pre><code>async def set_device_value_cmd(args: Namespace) -&gt; None:\n    \"\"\"Set one or more values on the device.\"\"\"\n    attrs = (\"name\", \"target_temp\", \"temperature_unit\", \"led_colour\", \"volume_level\")\n    values = [(attr, value) for attr in attrs if (value := getattr(args, attr, None))]\n    if not values:\n        print(\"Please specify at least one attribute and value to set.\")\n        options = [f\"--{a.replace('_', '-')}\" for a in attrs]\n        print(f'Options: {\", \".join(options)}')\n        sys.exit(1)\n\n    mug = await get_device(args)\n    async with mug.connection(adapter=args.adapter):\n        for attr, value in values:\n            method = getattr(mug, f'set_{attr.replace(\"-\", \"_\")}')\n            print(f\"Setting {attr} to {value}\")\n            try:\n                await method(value)\n            except NotImplementedError as e:\n                print(e)\n                sys.exit(1)\n</code></pre>"},{"location":"api/cli/helpers/","title":"cli.helpers","text":""},{"location":"api/cli/helpers/#cli.helpers","title":"cli.helpers","text":"<p>Helpers for CLI Interface.</p>"},{"location":"api/cli/helpers/#cli.helpers-attributes","title":"Attributes","text":""},{"location":"api/cli/helpers/#cli.helpers.base_formatters","title":"base_formatters  <code>module-attribute</code>","text":"<pre><code>base_formatters: dict[str, collections.abc.Callable] = {\n    \"led_colour\": ember_mug.formatting.format_led_colour,\n    \"liquid_level\": ember_mug.formatting.format_liquid_level,\n}\n</code></pre>"},{"location":"api/cli/helpers/#cli.helpers-classes","title":"Classes","text":""},{"location":"api/cli/helpers/#cli.helpers.CommandLoop","title":"CommandLoop","text":"<p>Class to handle command loop.</p> Source code in <code>ember_mug/cli/helpers.py</code> <pre><code>class CommandLoop:\n    \"\"\"Class to handle command loop.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Start running.\"\"\"\n        self.running = True\n\n    def __iter__(self) -&gt; Generator[None, None, None]:\n        \"\"\"Yield until stopped.\"\"\"\n        try:\n            while self.running:\n                yield\n        except KeyboardInterrupt:\n            self.running = False\n            raise\n</code></pre>"},{"location":"api/cli/helpers/#cli.helpers.CommandLoop-attributes","title":"Attributes","text":""},{"location":"api/cli/helpers/#cli.helpers.CommandLoop.running","title":"running  <code>instance-attribute</code>","text":"<pre><code>running = True\n</code></pre>"},{"location":"api/cli/helpers/#cli.helpers-functions","title":"Functions","text":""},{"location":"api/cli/helpers/#cli.helpers.build_sub_rows","title":"build_sub_rows","text":"<pre><code>build_sub_rows(\n    row: tuple[str, ...],\n) -&gt; dict[int, dict[int, str]]\n</code></pre> <p>Build a defaultdict of cells to pad for empty values.</p> Source code in <code>ember_mug/cli/helpers.py</code> <pre><code>def build_sub_rows(row: tuple[str, ...]) -&gt; dict[int, dict[int, str]]:\n    \"\"\"Build a defaultdict of cells to pad for empty values.\"\"\"\n    sub_rows: dict[int, dict[int, str]] = defaultdict(lambda: defaultdict(lambda: \"\"))\n    for i, col in enumerate(row):\n        for j, val in enumerate(str(col).split(\", \")):\n            sub_rows[j][i] = val\n    return sub_rows\n</code></pre>"},{"location":"api/cli/helpers/#cli.helpers.print_changes","title":"print_changes","text":"<pre><code>print_changes(\n    changes: list[ember_mug.data.Change],\n    metric: bool = True,\n) -&gt; None\n</code></pre> <p>Print changes.</p> Source code in <code>ember_mug/cli/helpers.py</code> <pre><code>def print_changes(changes: list[Change], metric: bool = True) -&gt; None:\n    \"\"\"Print changes.\"\"\"\n    formatters: dict[str, Callable] = {\n        \"current_temp\": partial(format_temp, metric=metric),\n        \"target_temp\": partial(format_temp, metric=metric),\n        **base_formatters,\n    }\n    for attr, old_value, new_value in changes:\n        if formatter := formatters.get(attr):\n            old_value, new_value = formatter(old_value), formatter(new_value)  # noqa: PLW2901\n        print(Change(attr, old_value, new_value))\n</code></pre>"},{"location":"api/cli/helpers/#cli.helpers.print_info","title":"print_info","text":"<pre><code>print_info(mug: ember_mug.mug.EmberMug) -&gt; None\n</code></pre> <p>Print all mug data.</p> Source code in <code>ember_mug/cli/helpers.py</code> <pre><code>def print_info(mug: EmberMug) -&gt; None:\n    \"\"\"Print all mug data.\"\"\"\n    print(\"Device Data\")\n    print_table(list(mug.data.formatted.items()))\n</code></pre>"},{"location":"api/cli/helpers/#cli.helpers.print_table","title":"print_table","text":"<pre><code>print_table(data: list[tuple[str, ...]]) -&gt; None\n</code></pre> <p>Print data in a nice little ASCII table.</p> Source code in <code>ember_mug/cli/helpers.py</code> <pre><code>def print_table(data: list[tuple[str, ...]]) -&gt; None:\n    \"\"\"Print data in a nice little ASCII table.\"\"\"\n    if not data:\n        return\n    rows = [build_sub_rows(r) for r in data]\n    num_columns = max(len(sr) for r in rows for sr in r.values())\n    column_sizes = [max(len(sr[i]) for r in rows for sr in r.values()) + 2 for i in range(num_columns)]\n    vertical = f'+{\"+\".join(\"-\" * i for i in column_sizes)}+'\n    print(vertical)\n    for row in rows:\n        for sub_row in row.values():\n            inner = \"|\".join(f\" {sub_row[i]:&lt;{width-2}} \" for i, width in enumerate(column_sizes))\n            print(f\"|{inner}|\")\n        print(vertical)\n</code></pre>"},{"location":"api/cli/helpers/#cli.helpers.validate_mac","title":"validate_mac","text":"<pre><code>validate_mac(value: str) -&gt; str\n</code></pre> <p>Check if specified MAC Address is valid.</p> Source code in <code>ember_mug/cli/helpers.py</code> <pre><code>def validate_mac(value: str) -&gt; str:\n    \"\"\"Check if specified MAC Address is valid.\"\"\"\n    if not isinstance(value, str) or not re.match(MAC_ADDRESS_REGEX, value):\n        raise ArgumentTypeError(\"Invalid MAC Address\")\n    return value.lower()\n</code></pre>"},{"location":"usage/cli/","title":"CLI","text":"<p>Once this library is installed in your active python environment you can also use the <code>ember-mug</code> to interact with your device. If you clone this project you may also run the commands via <code>hatch</code> in the project root. Simply use <code>hatch run ember-mug</code> with your desired options</p>"},{"location":"usage/cli/#command-overview","title":"Command Overview","text":"Command Use <code>discover</code> Find/List all detected unpaired devices in pairing mode <code>find</code> Find one already paired devices <code>info</code> Connect to one device and print its current state <code>poll</code> Connect to one device and print its current state and keep watching for changes <code>get</code> Get the value(s) of one or more attribute(s) by name <code>set</code> Set one or more values on the device <p>A few useful common arguments: - <code>--mac your:mac:address</code> (or <code>-m</code>) to restrict to that address (useful if you have multiple devices) - <code>--raw</code> (or <code>-r</code>) flag to restrict to very basic and parsable output (useful if you want to use the output in a script.) - <code>--debug</code> (or <code>-d</code>) flag to enable very verbose output</p> <p>Some commands have extra options. You can see them by using the <code>--help</code> flag after specifying a command. ex. <pre><code>ember-mug set --help\n</code></pre></p>"},{"location":"usage/cli/#examples","title":"Examples","text":""},{"location":"usage/cli/#find-a-device-in-pairing-mode-for-the-first-time","title":"Find a device in pairing mode (for the first time)","text":"ember-mug discoverFound Mug: C9:0F:59:D6:33:F9Name: EMBER MUGModel: Ember Mug 2 [CM19/CM21M]Colour: BlackCapacity: 295ml"},{"location":"usage/cli/#find-a-previously-paired-device","title":"Find a previously paired device","text":"ember-mug discoverFound device: C9:0F:59:D6:33:F9: Ember Ceramic Mug"},{"location":"usage/cli/#fetch-info-and-keep-listening-for-changes","title":"Fetch info and keep listening for changes","text":"ember-mug pollFound mug: C9:0F:59:D6:33:F9: Ember Ceramic Mug"},{"location":"usage/cli/#get-the-values-of-specific-attributes","title":"Get the value(s) of specific attribute(s)","text":"ember-mug get name target-temp"},{"location":"usage/cli/#set-the-values-of-specific-attributes","title":"Set the value(s) of specific attribute(s)","text":"ember-mug set --name \"My mug\" --target-temp 56.8"},{"location":"usage/installation/","title":"Installation","text":""},{"location":"usage/installation/#installation","title":"Installation","text":"<p>To install Python Ember Mug, run this command in your terminal:</p> <pre><code>pip install python-ember-mug\n</code></pre> <p>This is the preferred method to install Python Ember Mug, as it will always install the most recent stable release.</p> <p>If you don't have <code>pip</code> installed, this Python installation guide can guide you through the process.</p>"},{"location":"usage/installation/#from-source","title":"From source","text":"<p>The source for Python Ember Mug can be downloaded from the GitHub repo.</p> <p>You can either clone the public repository:</p> <pre><code>git clone git://github.com/sopelj/python-ember-mug\n</code></pre> <p>Or download the tarball:</p> <pre><code>curl -OJL https://github.com/sopelj/python-ember-mug/tarball/main\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>pip install .\n</code></pre>"},{"location":"usage/python/","title":"Python","text":""},{"location":"usage/python/#in-order-to","title":"In order to","text":"<pre><code>from ember_mug.scanner import find_device, discover_devices\nfrom ember_mug.utils import get_model_info_from_advertiser_data\nfrom ember_mug.mug import EmberMug\n\n# if first time with mug in pairing\ndevices = await discover_devices()\n\n# after paired you can simply use\ndevice, advertisement = await find_device()\nmodel_info = get_model_info_from_advertiser_data(advertisement)\nmug = EmberMug(device, model_info)\nawait mug.update_all()\nprint(mug.data.formatted)\nawait mug.disconnect()\n\n# You can also use connection as a context manager\n# if you want to ensure connection before starting and cleanup on exit\nasync with mug.connection():\n    print('Connected.\\nFetching Info')\n    await mug.update_all()\n    print(mug.data.formatted)\n</code></pre>"}]}